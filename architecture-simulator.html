<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Architecture Simulator - Solution Architect Tool</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/hotkeys-js/3.8.7/hotkeys.min.js" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Kalam:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #fafafa;
            min-height: 100vh;
            overflow-x: hidden;
            color: #2d3748;
            line-height: 1.6;
        }

        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        .header {
            background: #ffffff;
            border-bottom: 1px solid #e5e7eb;
            padding: 0.75rem 1rem;
            position: sticky;
            top: 0;
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .header-left {
            display: flex;
            flex-direction: column;
        }

        .header h1 {
            color: #111827;
            font-size: 1.25rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            letter-spacing: -0.025em;
        }

        .header .subtitle {
            color: #6b7280;
            font-size: 0.75rem;
            margin-top: 0.125rem;
            font-weight: 400;
        }

        .header-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .quick-actions {
            display: flex;
            gap: 0.25rem;
            align-items: center;
            flex-wrap: wrap;
        }

        @media (max-width: 1200px) {
            .quick-actions {
                gap: 0.125rem;
            }
            
            .quick-btn {
                padding: 0.375rem 0.75rem;
                font-size: 0.8rem;
            }
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 1rem;
                padding: 1rem;
            }
            
            .header-controls {
                width: 100%;
                justify-content: center;
            }
            
            .quick-actions {
                justify-content: center;
                flex-wrap: wrap;
            }
        }

        .quick-btn {
            padding: 0.5rem;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            gap: 0.375rem;
            background: #ffffff;
            color: #374151;
            min-width: 36px;
            height: 36px;
            justify-content: center;
        }

        .quick-btn:hover {
            background: #f9fafb;
            border-color: #d1d5db;
        }

        .quick-btn.active {
            background: #6366f1;
            color: white;
            border-color: #6366f1;
        }

        .quick-btn.active:hover {
            background: #5b5bd6;
            border-color: #5b5bd6;
        }

        .quick-btn-primary {
            background: #6366f1;
            color: white;
            border-color: #6366f1;
        }

        .quick-btn-success {
            background: #10b981;
            color: white;
            border-color: #10b981;
        }

        .quick-btn-warning {
            background: #f59e0b;
            color: white;
            border-color: #f59e0b;
        }

        .quick-btn-danger {
            background: #ef4444;
            color: white;
            border-color: #ef4444;
        }

        .quick-btn-secondary {
            background: #ffffff;
            color: #4a5568;
            border-color: #e2e8f0;
        }

        .quick-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border-color: #cbd5e0;
        }

        .quick-btn-primary:hover {
            background: #5b5bd6;
            border-color: #5b5bd6;
        }

        .quick-btn-success:hover {
            background: #059669;
            border-color: #059669;
        }

        .quick-btn-warning:hover {
            background: #d97706;
            border-color: #d97706;
        }

        .quick-btn-danger:hover {
            background: #dc2626;
            border-color: #dc2626;
        }

        .main-container {
            display: flex;
            height: calc(100vh - 80px);
            gap: 0;
            padding: 0;
            min-height: 0;
            overflow: hidden;
            flex-direction: row;
            position: relative;
            z-index: 1;
        }

        .main-container.hand-mode {
            flex-direction: row !important;
        }

        .sidebar {
            width: 320px;
            min-width: 320px;
            max-width: 320px;
            background: linear-gradient(180deg, #ffffff 0%, #f8fafc 100%);
            border-right: 1px solid #e2e8f0;
            padding: 0;
            overflow-y: auto;
            position: fixed !important;
            top: 80px !important;
            left: 0 !important;
            bottom: 0 !important;
            flex-shrink: 0;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.04);
            z-index: 9999 !important; /* Highest z-index - sidebar is always on top */
            transition: transform 0.3s ease-in-out;
        }

        .sidebar.collapsed {
            transform: translateX(-100%);
        }

        .sidebar-header {
            padding: 1.5rem 1.25rem 1rem;
            background: #ffffff;
            border-bottom: 1px solid #f1f5f9;
            position: sticky;
            top: 0;
            z-index: 10000 !important; /* Highest z-index - sidebar header is always on top */
        }

        .sidebar-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: #1e293b;
            margin: 0 0 0.75rem 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .sidebar-title i {
            color: #6366f1;
            font-size: 1rem;
        }

        .search-container {
            position: relative;
        }

        .search-box {
            width: 100%;
            padding: 0.75rem 1rem 0.75rem 2.5rem;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            font-size: 0.875rem;
            transition: all 0.2s ease;
            background: #f8fafc;
            color: #475569;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            z-index: 9999 !important; /* Highest z-index - search box is always on top */
        }

        .search-box:focus {
            outline: none;
            border-color: #6366f1;
            background: #ffffff;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .search-box::placeholder {
            color: #94a3b8;
        }

        .search-icon {
            position: absolute;
            left: 0.875rem;
            top: 50%;
            transform: translateY(-50%);
            color: #94a3b8;
            font-size: 0.875rem;
        }

        .sidebar-content {
            padding: 1.25rem;
            position: relative;
            z-index: 9999 !important; /* Highest z-index - sidebar content is always on top */
        }

        .section {
            margin-bottom: 2rem;
            position: relative;
            z-index: 9999 !important; /* Highest z-index - section content is always on top */
        }

        /* Ensure all sidebar elements are above everything */
        .sidebar * {
            position: relative;
            z-index: 9999 !important;
        }

        /* Force sidebar to be on top of everything */
        .sidebar {
            z-index: 9999 !important;
            position: fixed !important;
            top: 80px !important;
            left: 0 !important;
            bottom: 0 !important;
        }

        /* Ensure workspace and canvas are below sidebar */
        .workspace {
            z-index: 1 !important;
        }

        .canvas {
            z-index: 2 !important;
        }

        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }

        .section-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: #475569;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .section-title i {
            color: #6366f1;
            font-size: 0.75rem;
        }

        .section-count {
            background: #e2e8f0;
            color: #64748b;
            font-size: 0.75rem;
            font-weight: 500;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            min-width: 20px;
            text-align: center;
        }


        .template-section {
            margin-bottom: 2rem;
        }

        .template-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.8rem;
            margin-bottom: 1rem;
        }

        .template-card {
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 1.25rem;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            position: relative;
            overflow: hidden;
            z-index: 9999 !important; /* Highest z-index - template cards are always on top */
        }

        .template-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #6366f1, #8b5cf6);
            transform: scaleX(0);
            transition: transform 0.2s ease;
        }

        .template-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            border-color: #cbd5e0;
            background: #f8fafc;
        }

        .template-card:hover::before {
            transform: scaleX(1);
        }

        .template-icon {
            font-size: 1.5rem;
            color: #3182ce;
            margin-bottom: 0.5rem;
        }

        .template-title {
            font-weight: 500;
            color: #1a202c;
            font-size: 0.875rem;
        }

        .history-section {
            margin-bottom: 2rem;
        }

        .history-item {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .history-item:hover {
            background: #edf2f7;
            border-color: #cbd5e0;
        }

        .history-time {
            font-size: 0.75rem;
            color: #a0aec0;
        }

        .workspace {
            flex: 1;
            min-width: 0;
            background: #f8fafc;
            position: relative;
            overflow: hidden; /* Prevent overflow issues */
            padding: 1rem;
            display: flex;
            flex-direction: column;
            margin-left: 320px; /* Push workspace to the right of sidebar */
            z-index: 1; /* Ensure workspace is below sidebar */
        }

        /* Ensure workspace doesn't cover sidebar */
        .workspace {
            margin-left: 320px !important;
            width: calc(100vw - 320px) !important;
            transition: margin-left 0.3s ease-in-out, width 0.3s ease-in-out;
        }

        .workspace.sidebar-collapsed {
            margin-left: 0 !important;
            width: 100vw !important;
        }

        .component-library {
            margin-bottom: 2rem;
        }

        .library-title {
            font-size: 1rem;
            font-weight: 600;
            color: #1a202c;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            letter-spacing: -0.025em;
        }

        .component-category {
            margin-bottom: 1.5rem;
        }

        .category-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 0.75rem;
            padding: 0.5rem 0.75rem;
            background: #f7fafc;
            border-radius: 6px;
            text-align: left;
            border-left: 3px solid #3182ce;
        }

        .component-item {
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 0.875rem;
            margin-bottom: 0.5rem;
            cursor: grab;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            position: relative;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            z-index: 9999 !important; /* Highest z-index - component items are always on top */
        }

        .component-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border-color: #cbd5e0;
            background: #f8fafc;
        }

        .component-item:active {
            transform: scale(0.98);
            cursor: grabbing;
        }

        .component-icon {
            font-size: 1.125rem;
            color: #6366f1;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f1f5f9;
            border-radius: 6px;
            flex-shrink: 0;
        }

        .component-info {
            flex: 1;
            min-width: 0;
        }

        .component-info h4 {
            font-size: 0.875rem;
            color: #1e293b;
            margin-bottom: 0.25rem;
            font-weight: 600;
            line-height: 1.2;
        }

        .component-info p {
            font-size: 0.75rem;
            color: #64748b;
            line-height: 1.3;
        }

        .component-cost {
            font-size: 0.75rem;
            color: #059669;
            font-weight: 600;
            background: #ecfdf5;
            padding: 0.25rem 0.5rem;
            border-radius: 6px;
            border: 1px solid #d1fae5;
            white-space: nowrap;
        }

        .canvas {
            width: calc(100vw - 320px);
            height: calc(100vh - 80px);
            background: #ffffff;
            position: fixed;
            top: 80px;
            left: 320px;
            right: 0;
            bottom: 0;
            overflow: auto;
            z-index: 2; /* Above workspace but below sidebar */
            border: none;
            border-radius: 0;
            box-shadow: none;
            min-width: 4000px;
            min-height: 4000px;
            scroll-behavior: smooth;
            cursor: grab;
            transform-origin: top left;
            will-change: transform;
            transform: translateZ(0); /* Force hardware acceleration */
        }

        /* Ensure canvas doesn't cover sidebar */
        .canvas {
            left: 320px !important;
            width: calc(100vw - 320px) !important;
            transition: left 0.3s ease-in-out, width 0.3s ease-in-out;
        }

        .canvas.sidebar-collapsed {
            left: 0 !important;
            width: 100vw !important;
        }

        .canvas.hand-mode {
            left: 320px !important;
            width: calc(100vw - 320px) !important;
            position: fixed !important;
            top: 80px !important;
            right: 0 !important;
            bottom: 0 !important;
            z-index: 2 !important; /* Above workspace but below sidebar */
        }

        /* Ensure hand mode doesn't cover sidebar */
        .canvas.hand-mode {
            left: 320px !important;
            width: calc(100vw - 320px) !important;
            z-index: 2 !important;
        }

        /* Ensure sidebar stays on top even in hand mode */
        .hand-mode .sidebar {
            z-index: 9999 !important;
            position: fixed !important;
            top: 80px !important;
            left: 0 !important;
            bottom: 0 !important;
        }

        /* Connection Mode Styles */
        .connection-mode {
            cursor: crosshair !important;
        }

        .connection-mode .dropped-component {
            cursor: pointer !important;
            position: relative;
        }

        .dropped-component.connecting {
            border-color: #3b82f6 !important;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3) !important;
            cursor: move !important;
        }

        .dropped-component.connection-target {
            border-color: #22c55e !important;
            box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.3) !important;
            cursor: crosshair !important;
        }

        /* Connection Points */
        .connection-point {
            position: absolute;
            width: 16px;
            height: 16px;
            background: #3b82f6;
            border: 3px solid white;
            border-radius: 50%;
            cursor: crosshair;
            z-index: 1200; /* above arrows while connecting */
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .connection-point:hover {
            background: #22c55e;
            transform: scale(1.2);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .connection-point.dragging {
            background: #22c55e;
            transform: scale(1.3);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        /* Connection point positions */
        .connection-point.top {
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
        }

        .connection-point.right {
            top: 50%;
            right: -6px;
            transform: translateY(-50%);
        }

        .connection-point.bottom {
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
        }

        .connection-point.left {
            top: 50%;
            left: -6px;
            transform: translateY(-50%);
        }

        /* Temporary connection line during drag */
        .temp-connection-line {
            position: absolute;
            pointer-events: none;
            z-index: 1100;
            stroke: #3b82f6;
            stroke-width: 3;
            stroke-dasharray: 8,4;
            fill: none;
            filter: drop-shadow(0 0 4px rgba(59, 130, 246, 0.5));
        }

        /* Snap indicator */
        .snap-indicator {
            position: absolute;
            width: 24px;
            height: 24px;
            background: #22c55e;
            border: 4px solid white;
            border-radius: 50%;
            z-index: 25;
            pointer-events: none;
            animation: snapPulse 0.5s ease-in-out infinite;
            box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.3);
        }

        @keyframes snapPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.7; }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Connection Arrow Styles */
        .connection-arrow {
            position: absolute;
            pointer-events: auto; /* allow clicking the arrow */
            z-index: 100; /* above components */
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            cursor: pointer;
            transition: opacity .15s ease;
        }

        .connection-arrow:hover { opacity: .85; z-index: 150; }
        .connection-arrow.selected { filter: drop-shadow(0 0 0.35rem rgba(139,92,246,.6)); }

        .connection-line {
            stroke: #3b82f6;
            stroke-width: 3;
            fill: none;
            filter: drop-shadow(0 0 2px rgba(59, 130, 246, 0.5));
        }

        .connection-line.active {
            stroke: #22c55e;
            stroke-width: 4;
            stroke-dasharray: none;
            animation: none;
        }

        .connection-arrowhead {
            fill: #3b82f6;
        }

        .connection-arrowhead.active {
            fill: #22c55e;
        }

        @keyframes dash {
            to { stroke-dashoffset: -10; }
        }

        /* Connection Info Panel */
        .connection-info {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            z-index: 10000;
            min-width: 300px;
            display: none;
        }

        .connection-info h3 {
            margin: 0 0 1rem 0;
            color: #1f2937;
            font-size: 1.25rem;
        }

        /* Arrow Styling Panel */
        .arrow-styling-panel {
            position: fixed !important;
            top: 100px !important;
            right: 20px !important;
            background: white !important;
            border: 2px solid #8b5cf6 !important;
            border-radius: 12px !important;
            padding: 16px !important;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.2) !important;
            z-index: 10002 !important;
            min-width: 200px !important;
            display: none;
            pointer-events: auto !important;
        }

        /* Floating Arrow Style Panel (Excalidraw style) */
        .floating-arrow-panel {
            position: absolute !important;
            background: white !important;
            border: 1px solid #e5e7eb !important;
            border-radius: 8px !important;
            padding: 12px !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
            z-index: 10003 !important;
            min-width: 180px !important;
            display: none;
            pointer-events: auto !important;
            font-size: 12px !important;
        }

        .floating-arrow-panel.show {
            display: block !important;
        }

        .floating-arrow-panel h4 {
            margin: 0 0 8px 0;
            font-size: 11px;
            font-weight: 600;
            color: #374151;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .floating-arrow-panel .styling-options {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
        }

        .floating-arrow-panel .styling-option {
            flex: 1;
            padding: 4px 6px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 24px;
            font-size: 10px;
        }

        .floating-arrow-panel .styling-option:hover {
            border-color: #9ca3af;
            background: #f9fafb;
        }

        .floating-arrow-panel .styling-option.active {
            border-color: #8b5cf6;
            background: #f3f4f6;
        }

        .arrow-styling-panel h3 {
            margin: 0 0 16px 0;
            font-size: 14px;
            font-weight: 600;
            color: #374151;
        }

        /* Ensure panel is always visible */
        .arrow-styling-panel.show {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        .styling-section {
            margin-bottom: 16px;
        }

        .styling-section h4 {
            margin: 0 0 8px 0;
            font-size: 12px;
            font-weight: 500;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .styling-options {
            display: flex;
            gap: 8px;
        }

        .styling-option {
            flex: 1;
            padding: 8px;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 32px;
            position: relative;
        }

        .styling-option:hover {
            border-color: #d1d5db;
            background: #f9fafb;
        }

        .styling-option.active {
            border-color: #8b5cf6;
            background: #f3f4f6;
        }

        .stroke-width-option::after {
            content: '';
            position: absolute;
            bottom: 4px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 2px;
            background: #374151;
            border-radius: 1px;
        }

        .stroke-width-option.thin::after {
            height: 1px;
        }

        .stroke-width-option.medium::after {
            height: 2px;
        }

        .stroke-width-option.thick::after {
            height: 3px;
        }

        .stroke-style-option::after {
            content: '';
            position: absolute;
            bottom: 4px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 2px;
            background: #374151;
            border-radius: 1px;
        }

        .stroke-style-option.dashed::after {
            background: repeating-linear-gradient(
                to right,
                #374151 0,
                #374151 4px,
                transparent 4px,
                transparent 8px
            );
        }

        .stroke-style-option.dotted::after {
            background: repeating-linear-gradient(
                to right,
                #374151 0,
                #374151 2px,
                transparent 2px,
                transparent 4px
            );
        }

        .roughness-option::after {
            content: '';
            position: absolute;
            bottom: 4px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 2px;
            background: #374151;
            border-radius: 1px;
        }

        .roughness-option.low::after {
            background: repeating-linear-gradient(
                45deg,
                #374151 0,
                #374151 2px,
                transparent 2px,
                transparent 4px
            );
        }

        .roughness-option.medium::after {
            background: repeating-linear-gradient(
                45deg,
                #374151 0,
                #374151 1px,
                transparent 1px,
                transparent 2px
            );
        }

        .roughness-option.high::after {
            background: repeating-linear-gradient(
                45deg,
                #374151 0,
                #374151 1px,
                transparent 1px,
                transparent 1px
            );
        }

        .arrow-type-option::after {
            content: '';
            position: absolute;
            bottom: 4px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 2px;
            background: #374151;
            border-radius: 1px;
        }

        .arrow-type-option.curved::after {
            background: radial-gradient(ellipse at center, transparent 0%, transparent 30%, #374151 30%, #374151 100%);
            width: 80%;
            height: 1px;
            border-radius: 50%;
        }

        .arrow-type-option.right-angled::after {
            background: linear-gradient(90deg, #374151 0%, #374151 40%, transparent 40%, transparent 60%, #374151 60%, #374151 100%);
        }

        .arrowhead-option::after {
            content: '';
            position: absolute;
            bottom: 4px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 8px solid #374151;
        }

        .arrowhead-option.circle::after {
            width: 8px;
            height: 8px;
            border: none;
            background: #374151;
            border-radius: 50%;
        }

        .arrowhead-option.diamond::after {
            width: 8px;
            height: 8px;
            border: none;
            background: #374151;
            transform: translateX(-50%) rotate(45deg);
        }

        .arrowhead-option.line::after {
            width: 12px;
            height: 2px;
            border: none;
            background: #374151;
            transform: translateX(-50%);
        }

        .connection-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .connection-form input,
        .connection-form select,
        .connection-form textarea {
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 0.875rem;
        }

        .connection-form textarea {
            resize: vertical;
            min-height: 80px;
        }

        .connection-buttons {
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
        }

        .connection-buttons button {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .connection-buttons .save-btn {
            background: #3b82f6;
            color: white;
        }

        .connection-buttons .save-btn:hover {
            background: #2563eb;
        }

        .connection-buttons .cancel-btn {
            background: #6b7280;
            color: white;
        }

        .connection-buttons .cancel-btn:hover {
            background: #4b5563;
        }

        /* Connection List */
        .connections-list {
            position: fixed;
            top: 120px;
            right: 20px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            max-width: 300px;
            display: none;
        }

        .connections-list h4 {
            margin: 0 0 1rem 0;
            color: #1f2937;
            font-size: 1rem;
        }

        .connection-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            background: #f9fafb;
        }

        .connection-item:hover {
            background: #f3f4f6;
        }

        .connection-item .connection-label {
            font-size: 0.875rem;
            color: #374151;
        }

        .connection-item .delete-btn {
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            cursor: pointer;
        }

        .connection-item .delete-btn:hover {
            background: #dc2626;
        }

        @media (max-width: 768px) {
            .canvas {
                width: calc(100vw - 280px);
                left: 280px;
            }
        }

        @media (max-width: 480px) {
            .canvas {
                width: 100vw;
                left: 0;
                top: 60px;
                height: calc(100vh - 60px);
            }
        }

        .canvas:active {
            cursor: grabbing;
        }

        .dropped-component {
            position: absolute;
            background: #ffffff;
            border: 2px solid #3182ce;
            border-radius: 8px;
            padding: 0.875rem;
            min-width: 140px;
            cursor: move;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: box-shadow 0.2s ease, transform 0.2s ease;
            z-index: 4;
            user-select: none;
            pointer-events: auto;
            transform-origin: center;
            will-change: transform;
            transform: translateZ(0); /* Force hardware acceleration */
        }

        .dropped-component.dragging {
            transition: none;
            z-index: 1000;
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            will-change: transform, left, top;
        }


        .dropped-component.selected {
            border-color: #e53e3e;
            box-shadow: 0 0 0 3px rgba(229, 62, 62, 0.2);
        }

        .component-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .component-title {
            font-weight: 500;
            color: #1a202c;
            font-size: 0.875rem;
        }

        .component-cost-display {
            font-size: 0.75rem;
            color: #38a169;
            font-weight: 600;
            background: #f0fff4;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            border: 1px solid #c6f6d5;
        }

        .delete-btn {
            background: #e53e3e;
            color: white;
            border: none;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            cursor: pointer;
            font-size: 0.625rem;
            position: absolute;
            top: -6px;
            right: -6px;
            display: none;
            transition: all 0.2s ease;
        }

        .delete-btn:hover {
            background: #c53030;
            transform: scale(1.1);
        }

        .dropped-component:hover .delete-btn {
            display: block;
        }

        .connection-line {
            position: absolute;
            background: #3498db;
            height: 2px;
            z-index: 5;
            pointer-events: none;
        }

        .simulation-panel {
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 1.25rem;
            margin-bottom: 1.5rem;
        }

        .simulation-title {
            font-size: 1rem;
            font-weight: 600;
            color: #1a202c;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: #f7fafc;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            border: 1px solid #e2e8f0;
        }

        .metric-label {
            font-weight: 500;
            color: #4a5568;
            font-size: 0.875rem;
        }

        .metric-value {
            font-weight: 600;
            color: #38a169;
            font-size: 0.875rem;
        }

        .metric-value.warning {
            color: #d69e2e;
        }

        .metric-value.danger {
            color: #e53e3e;
        }


        .btn {
            padding: 0.625rem 1rem;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            background: #ffffff;
            color: #4a5568;
        }

        .btn-primary {
            background: #3182ce;
            color: white;
            border-color: #3182ce;
        }

        .btn-primary:hover {
            background: #2c5aa0;
            border-color: #2c5aa0;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(49, 130, 206, 0.2);
        }

        .btn-success {
            background: #38a169;
            color: white;
            border-color: #38a169;
        }

        .btn-success:hover {
            background: #2f855a;
            border-color: #2f855a;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(56, 161, 105, 0.2);
        }

        .btn-warning {
            background: #d69e2e;
            color: white;
            border-color: #d69e2e;
        }

        .btn-warning:hover {
            background: #b7791f;
            border-color: #b7791f;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(214, 158, 46, 0.2);
        }

        .data-flow {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #3182ce;
            border-radius: 50%;
            animation: dataFlow 2s linear infinite;
            z-index: 15;
            box-shadow: 0 0 12px rgba(49, 130, 206, 0.8);
        }

        @keyframes dataFlow {
            0% { 
                opacity: 1; 
                transform: scale(1);
                box-shadow: 0 0 8px rgba(49, 130, 206, 0.6);
            }
            50% { 
                opacity: 0.8; 
                transform: scale(1.3);
                box-shadow: 0 0 12px rgba(49, 130, 206, 0.8);
            }
            100% { 
                opacity: 0; 
                transform: scale(0.5);
                box-shadow: 0 0 4px rgba(49, 130, 206, 0.3);
            }
        }

        .connection-line {
            position: absolute;
            background: #3182ce;
            height: 3px;
            z-index: 5;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            box-shadow: 0 0 4px rgba(49, 130, 206, 0.3);
        }

        .connection-line.active {
            opacity: 0.8;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        @keyframes dataPacketPulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4);
            }
            50% { 
                transform: scale(1.1);
                box-shadow: 0 4px 12px rgba(59, 130, 246, 0.6);
            }
        }

        .data-flow-active {
            border-color: #22c55e !important;
            box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.3) !important;
            animation: dataFlowHighlight 1s ease-in-out;
        }

        @keyframes dataFlowHighlight {
            0% { 
                transform: scale(1);
                box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.3);
            }
            50% { 
                transform: scale(1.05);
                box-shadow: 0 0 0 6px rgba(34, 197, 94, 0.5);
            }
            100% { 
                transform: scale(1);
                box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.3);
            }
        }

        .data-packet {
            position: absolute;
            z-index: 1000;
            pointer-events: none;
        }

        .template-connection-svg {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .template-connection-line {
            position: absolute;
            background: linear-gradient(45deg, #3b82f6, #1d4ed8);
            z-index: 10;
            pointer-events: none;
            border-radius: 2px;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
            transition: all 0.3s ease;
        }

        .template-arrowhead {
            position: absolute;
            z-index: 11;
            pointer-events: none;
        }

        /* Ensure components can still be moved */
        .dropped-component {
            cursor: move !important;
            user-select: none;
        }

        .dropped-component:hover {
            transform: scale(1.02);
            transition: transform 0.2s ease;
        }

        .simulation-overlay {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 320px;
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            z-index: 3000;
            display: none;
            border: 1px solid #e2e8f0;
        }

        .simulation-panel {
            background: transparent;
            border-radius: 0;
            padding: 0;
            max-width: none;
            width: 100%;
            box-shadow: none;
        }

        .simulation-step {
            display: none;
            text-align: left;
        }

        .simulation-step.active {
            display: block;
        }

        .simulation-step h3 {
            color: #1a202c;
            margin-bottom: 0.75rem;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .simulation-step p {
            color: #4a5568;
            margin-bottom: 1rem;
            line-height: 1.5;
            font-size: 0.875rem;
        }

        .simulation-progress {
            width: 100%;
            height: 3px;
            background: #e2e8f0;
            border-radius: 2px;
            margin: 0.75rem 0;
            overflow: hidden;
        }

        .simulation-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #3182ce, #38a169);
            border-radius: 2px;
            width: 0%;
            transition: width 0.5s ease;
        }

        .simulation-controls {
            display: flex;
            gap: 0.5rem;
            justify-content: flex-start;
            margin-top: 1rem;
        }

        .simulation-close {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            background: none;
            border: none;
            font-size: 1.25rem;
            cursor: pointer;
            color: #a0aec0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .simulation-close:hover {
            color: #4a5568;
        }

        .flow-indicator {
            position: absolute;
            background: #3182ce;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
            z-index: 20;
            pointer-events: none;
            animation: flowIndicator 2s linear infinite;
            box-shadow: 0 2px 8px rgba(49, 130, 206, 0.4);
        }

        @keyframes flowIndicator {
            0% { opacity: 0; transform: scale(0.8); }
            20% { opacity: 1; transform: scale(1); }
            80% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.8); }
        }

        .component-highlight {
            animation: highlight 1s ease-in-out;
        }

        @keyframes highlight {
            0% { 
                box-shadow: 0 0 0 0 rgba(49, 130, 206, 0.7);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 0 10px rgba(49, 130, 206, 0.3);
                transform: scale(1.05);
            }
            100% { 
                box-shadow: 0 0 0 0 rgba(49, 130, 206, 0);
                transform: scale(1);
            }
        }

        .simulation-status {
            position: fixed;
            top: 20px;
            left: 20px;
            background: #3182ce;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 500;
            z-index: 2000;
            display: none;
            box-shadow: 0 2px 8px rgba(49, 130, 206, 0.3);
            max-width: 200px;
        }

        .simulation-status.show {
            display: block;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .simulation-mini {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(49, 130, 206, 0.9);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 500;
            z-index: 2000;
            display: none;
            backdrop-filter: blur(10px);
        }

        .simulation-mini.show {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .performance-indicator {
            position: absolute;
            top: 16px;
            right: 16px;
            background: #ffffff;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 500;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            border: 1px solid #e2e8f0;
        }

        .performance-indicator.good {
            color: #38a169;
            border-left: 3px solid #38a169;
        }

        .performance-indicator.warning {
            color: #d69e2e;
            border-left: 3px solid #d69e2e;
        }

        .performance-indicator.danger {
            color: #e53e3e;
            border-left: 3px solid #e53e3e;
        }

        .tooltip {
            position: absolute;
            background: #1a202c;
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            font-size: 0.75rem;
            pointer-events: none;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 4000px;
            height: 4000px;
            background-image: 
                linear-gradient(rgba(0, 0, 0, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 0, 0, 0.05) 1px, transparent 1px);
            background-size: 20px 20px;
            pointer-events: none;
            opacity: 0.3;
            z-index: 0;
        }

        .canvas-instruction {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 1.5rem 2rem;
            border-radius: 12px;
            border: 1px solid #e5e7eb;
            color: #6b7280;
            font-size: 1rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            pointer-events: none;
            z-index: 3;
            backdrop-filter: blur(8px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            text-align: center;
            max-width: 300px;
        }

        .canvas-instruction i {
            color: #3b82f6;
            font-size: 1.2rem;
            animation: pulse 2s infinite;
        }

        .canvas.has-components .canvas-instruction {
            display: none !important;
        }

        .canvas-instruction span {
            font-weight: 500;
            color: #374151;
        }

        .canvas-instruction:hover {
            transform: translate(-50%, -50%) scale(1.02);
            transition: transform 0.2s ease;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Hand-drawn style elements inspired by Excalidraw */
        .hand-drawn-border {
            border: 2px solid #4a5568;
            border-radius: 8px;
            position: relative;
        }

        .hand-drawn-border::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border: 1px solid #4a5568;
            border-radius: 8px;
            opacity: 0.3;
        }

        .sketchy-text {
            font-family: 'Kalam', cursive;
            font-weight: 400;
        }

        .wobbly {
            animation: wobble 0.5s ease-in-out;
        }

        @keyframes wobble {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(1deg); }
            75% { transform: rotate(-1deg); }
        }

        .hand-drawn-shadow {
            box-shadow: 
                0 1px 3px rgba(0, 0, 0, 0.1),
                0 1px 2px rgba(0, 0, 0, 0.06),
                0 0 0 1px rgba(0, 0, 0, 0.05);
        }

        .zoom-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 0.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background: #ffffff;
            color: #4a5568;
            cursor: pointer;
            font-size: 1.1rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-btn:hover {
            background: #f7fafc;
            border-color: #cbd5e0;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .zoom-level {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.875rem;
            font-weight: 500;
            color: #4a5568;
            border: 1px solid #e2e8f0;
            backdrop-filter: blur(10px);
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .hand-mode {
            cursor: grab !important;
        }

        .hand-mode:active {
            cursor: grabbing !important;
        }

        .hand-mode .dropped-component {
            pointer-events: auto;
        }

        .tool-mode-indicator {
            position: fixed;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            background: rgba(49, 130, 206, 0.9);
            color: white;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            font-size: 0.875rem;
            font-weight: 500;
            z-index: 1000;
            display: none;
            backdrop-filter: blur(10px);
        }

        .tool-mode-indicator.show {
            display: block;
            animation: slideInLeft 0.3s ease;
        }

        @keyframes slideInLeft {
            from { transform: translateY(-50%) translateX(-20px); opacity: 0; }
            to { transform: translateY(-50%) translateX(0); opacity: 1; }
        }

        .presentation-mode {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 2000;
            display: none;
        }

        .presentation-content {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .presentation-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            font-size: 1.5rem;
        }

        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 3000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .tutorial-content {
            background: white;
            border-radius: 15px;
            padding: 2rem;
            max-width: 500px;
            text-align: center;
            position: relative;
        }

        .tutorial-close {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #7f8c8d;
        }

        .tutorial-step {
            display: none;
        }

        .tutorial-step.active {
            display: block;
        }

        .tutorial-navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 2rem;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #27ae60;
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            transform: translateX(400px);
            transition: transform 0.3s ease;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.error {
            background: #e74c3c;
        }

        .notification.warning {
            background: #f39c12;
        }

        .keyboard-shortcuts {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            font-size: 0.8rem;
            z-index: 1000;
            display: none;
        }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .shortcut-key {
            background: #34495e;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-family: monospace;
        }

        .auto-save-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(52, 152, 219, 0.9);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.8rem;
            z-index: 1000;
            display: none;
        }

        .component-info-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 4000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        .component-info-content {
            background: white;
            border-radius: 15px;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .component-info-header {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            padding: 2rem;
            border-radius: 15px 15px 0 0;
            position: relative;
        }

        .component-info-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            font-size: 1.2rem;
        }

        .component-info-title {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .component-info-subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .component-info-body {
            padding: 2rem;
        }

        .info-section {
            margin-bottom: 2rem;
        }

        .info-section h3 {
            color: #2c3e50;
            font-size: 1.3rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .info-card {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 1rem;
        }

        .info-card-title {
            font-weight: 600;
            color: #495057;
            margin-bottom: 0.5rem;
        }

        .info-card-value {
            color: #2c3e50;
            font-size: 1.1rem;
        }

        .use-cases {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
        }

        .use-case {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            border: 1px solid #90caf9;
            border-radius: 8px;
            padding: 1rem;
        }

        .use-case-title {
            font-weight: 600;
            color: #1565c0;
            margin-bottom: 0.5rem;
        }

        .use-case-desc {
            color: #424242;
            font-size: 0.9rem;
        }

        .pros-cons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }

        .pros, .cons {
            padding: 1rem;
            border-radius: 8px;
        }

        .pros {
            background: linear-gradient(135deg, #e8f5e8, #c8e6c9);
            border: 1px solid #4caf50;
        }

        .cons {
            background: linear-gradient(135deg, #ffebee, #ffcdd2);
            border: 1px solid #f44336;
        }

        .pros h4, .cons h4 {
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .pros h4 {
            color: #2e7d32;
        }

        .cons h4 {
            color: #c62828;
        }

        .pros ul, .cons ul {
            list-style: none;
            padding: 0;
        }

        .pros li, .cons li {
            padding: 0.3rem 0;
            position: relative;
            padding-left: 1.5rem;
        }

        .pros li:before {
            content: "";
            position: absolute;
            left: 0;
            color: #4caf50;
            font-weight: bold;
        }

        .cons li:before {
            content: "";
            position: absolute;
            left: 0;
            color: #f44336;
            font-weight: bold;
        }

        .component-rating {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .stars {
            color: #ffc107;
            font-size: 1.2rem;
        }

        .rating-text {
            color: #6c757d;
            font-size: 0.9rem;
        }

        .learn-more-btn {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .learn-more-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(52, 152, 219, 0.3);
        }

        .component-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .tag {
            background: #e9ecef;
            color: #495057;
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .tag.aws { background: #ff9900; color: white; }
        .tag.azure { background: #0078d4; color: white; }
        .tag.database { background: #28a745; color: white; }
        .tag.security { background: #dc3545; color: white; }
        .tag.performance { background: #17a2b8; color: white; }
        .tag.serverless { background: #6f42c1; color: white; }

        .enhanced-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            font-size: 0.9rem;
            max-width: 300px;
            z-index: 1000;
            pointer-events: none;
            display: none;
        }

        .enhanced-tooltip h4 {
            margin-bottom: 0.5rem;
            color: #3498db;
        }

        .enhanced-tooltip p {
            margin-bottom: 0.5rem;
            line-height: 1.4;
        }

        .enhanced-tooltip .cost {
            color: #27ae60;
            font-weight: 600;
        }

        .component-item:hover .enhanced-tooltip {
            display: block;
        }

        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
                height: auto;
            }
            
            .sidebar {
                width: 100%;
                height: 300px;
            }
            
            .workspace {
                height: 500px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-left">
            <h1>
                <i class="fas fa-sitemap"></i>
                Architecture Simulator
            </h1>
            <p class="subtitle">Solution Architect Tool - Drag & Drop Architecture Design</p>
        </div>
        <div class="header-controls">
            <button class="quick-btn" id="sidebarToggleBtn" onclick="toggleSidebar()" title="Toggle Sidebar">
                <i class="fas fa-bars"></i>
                <span id="sidebarToggleText">Hide</span>
            </button>
            <div class="quick-actions">
                <button class="quick-btn" id="handToolBtn" onclick="toggleHandMode()">
                    <i class="fas fa-hand-paper"></i>
                    Hand
                </button>
                <button class="quick-btn" onclick="toggleArrowStyling()">
                    <i class="fas fa-palette"></i>
                    Style
                </button>
                <button class="quick-btn quick-btn-primary" onclick="simulateDataFlow()">
                    <i class="fas fa-play"></i>
                    Simulate
                </button>
                <button class="quick-btn quick-btn-success" onclick="exportArchitecture()">
                    <i class="fas fa-download"></i>
                    Export
                </button>
                <button class="quick-btn quick-btn-warning" onclick="togglePresentation()">
                    <i class="fas fa-presentation"></i>
                    Present
                </button>
                <button class="quick-btn quick-btn-secondary" onclick="showTutorial()">
                    <i class="fas fa-graduation-cap"></i>
                    Tutorial
                </button>
                <button class="quick-btn quick-btn-secondary" onclick="toggleShortcuts()">
                    <i class="fas fa-keyboard"></i>
                    Shortcuts
                </button>
                <button class="quick-btn quick-btn-danger" onclick="clearCanvas()">
                    <i class="fas fa-trash"></i>
                    Clear
                </button>
            </div>
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-title">
                    <i class="fas fa-cube"></i>
                    Component Library
                </div>
                <div class="search-container">
                    <i class="fas fa-search search-icon"></i>
                    <input type="text" class="search-box" placeholder="Search components..." id="componentSearch">
                </div>
            </div>
            <div class="sidebar-content">
            
            <div class="section">
                <div class="section-header">
                    <div class="section-title">
                        <i class="fas fa-layer-group"></i>
                        Quick Templates
                    </div>
                    <div class="section-count">4</div>
                </div>
                <div class="template-grid">
                    <div class="template-card" onclick="loadTemplate('web-app')">
                        <div class="template-icon"></div>
                        <div class="template-title">Web App</div>
                    </div>
                    <div class="template-card" onclick="loadTemplate('microservices')">
                        <div class="template-icon"></div>
                        <div class="template-title">Microservices</div>
                    </div>
                    <div class="template-card" onclick="loadTemplate('serverless')">
                        <div class="template-icon"></div>
                        <div class="template-title">Serverless</div>
                    </div>
                    <div class="template-card" onclick="loadTemplate('data-pipeline')">
                        <div class="template-icon"></div>
                        <div class="template-title">Data Pipeline</div>
                    </div>
                </div>
            </div>

            <div class="history-section">
                <div class="library-title">
                    <i class="fas fa-history"></i>
                    Recent Projects
                </div>
                <div id="projectHistory">
                    <div class="history-item" onclick="loadProject('project1')">
                        <span>E-commerce Architecture</span>
                        <span class="history-time">2 hours ago</span>
                    </div>
                    <div class="history-item" onclick="loadProject('project2')">
                        <span>API Gateway Setup</span>
                        <span class="history-time">Yesterday</span>
                    </div>
                </div>
            </div>

            <div class="simulation-panel">
                <div class="simulation-title">
                    <i class="fas fa-chart-line"></i>
                    Simulation Metrics
                </div>
                <div class="metric">
                    <span class="metric-label">Total Cost/Month</span>
                    <span class="metric-value" id="totalCost">$0</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Performance Score</span>
                    <span class="metric-value" id="performanceScore">100%</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Scalability</span>
                    <span class="metric-value" id="scalability">Good</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Security Level</span>
                    <span class="metric-value" id="securityLevel">High</span>
                </div>
            </div>


            <div class="section">
                <div class="section-header">
                    <div class="section-title">
                        <i class="fas fa-cubes"></i>
                        Components
                    </div>
                    <div class="section-count" id="componentCount">12</div>
                </div>

                <div class="component-category">
                    <div class="category-title">Cloud Providers</div>
                    <div class="component-item" draggable="true" data-component="aws-ec2" data-cost="50" onclick="showComponentInfo('aws-ec2')">
                        <i class="fab fa-aws component-icon"></i>
                        <div class="component-info">
                            <h4>AWS EC2</h4>
                            <p>Virtual Server</p>
                            <div class="component-cost">$50/mo</div>
                        </div>
                        <div class="enhanced-tooltip">
                            <h4>AWS EC2</h4>
                            <p>Elastic Compute Cloud - Scalable virtual servers in the cloud</p>
                            <p><strong>Use Cases:</strong> Web applications, APIs, microservices</p>
                            <p class="cost">Cost: $50/month</p>
                        </div>
                    </div>
                    <div class="component-item" draggable="true" data-component="aws-rds" data-cost="80" onclick="showComponentInfo('aws-rds')">
                        <i class="fas fa-database component-icon"></i>
                        <div class="component-info">
                            <h4>AWS RDS</h4>
                            <p>Managed Database</p>
                            <div class="component-cost">$80/mo</div>
                        </div>
                        <div class="enhanced-tooltip">
                            <h4>AWS RDS</h4>
                            <p>Relational Database Service - Managed database hosting</p>
                            <p><strong>Use Cases:</strong> Transactional data, user management, analytics</p>
                            <p class="cost">Cost: $80/month</p>
                        </div>
                    </div>
                    <div class="component-item" draggable="true" data-component="aws-lambda" data-cost="20" onclick="showComponentInfo('aws-lambda')">
                        <i class="fas fa-bolt component-icon"></i>
                        <div class="component-info">
                            <h4>AWS Lambda</h4>
                            <p>Serverless Function</p>
                            <div class="component-cost">$20/mo</div>
                        </div>
                        <div class="enhanced-tooltip">
                            <h4>AWS Lambda</h4>
                            <p>Serverless compute service - Run code without managing servers</p>
                            <p><strong>Use Cases:</strong> Event processing, APIs, data transformation</p>
                            <p class="cost">Cost: $20/month</p>
                        </div>
                    </div>
                    <div class="component-item" draggable="true" data-component="azure-vm" data-cost="45" onclick="showComponentInfo('azure-vm')">
                        <i class="fab fa-microsoft component-icon"></i>
                        <div class="component-info">
                            <h4>Azure VM</h4>
                            <p>Virtual Machine</p>
                            <div class="component-cost">$45/mo</div>
                        </div>
                        <div class="enhanced-tooltip">
                            <h4>Azure VM</h4>
                            <p>Azure Virtual Machines - Scalable cloud computing</p>
                            <p><strong>Use Cases:</strong> Enterprise apps, development, testing</p>
                            <p class="cost">Cost: $45/month</p>
                        </div>
                    </div>
                </div>

                <div class="component-category">
                    <div class="category-title">Load Balancing</div>
                    <div class="component-item" draggable="true" data-component="load-balancer" data-cost="30" onclick="showComponentInfo('load-balancer')">
                        <i class="fas fa-balance-scale component-icon"></i>
                        <div class="component-info">
                            <h4>Load Balancer</h4>
                            <p>Traffic Distribution</p>
                            <div class="component-cost">$30/mo</div>
                        </div>
                        <div class="enhanced-tooltip">
                            <h4>Load Balancer</h4>
                            <p>Distributes incoming traffic across multiple servers</p>
                            <p><strong>Use Cases:</strong> High availability, traffic management</p>
                            <p class="cost">Cost: $30/month</p>
                        </div>
                    </div>
                    <div class="component-item" draggable="true" data-component="api-gateway" data-cost="25" onclick="showComponentInfo('api-gateway')">
                        <i class="fas fa-door-open component-icon"></i>
                        <div class="component-info">
                            <h4>API Gateway</h4>
                            <p>API Management</p>
                            <div class="component-cost">$25/mo</div>
                        </div>
                        <div class="enhanced-tooltip">
                            <h4>API Gateway</h4>
                            <p>Centralized entry point for API management</p>
                            <p><strong>Use Cases:</strong> API security, rate limiting, monitoring</p>
                            <p class="cost">Cost: $25/month</p>
                        </div>
                    </div>
                </div>

                <div class="component-category">
                    <div class="category-title">Data & Storage</div>
                    <div class="component-item" draggable="true" data-component="redis-cache" data-cost="40" onclick="showComponentInfo('redis-cache')">
                        <i class="fas fa-memory component-icon"></i>
                        <div class="component-info">
                            <h4>Redis Cache</h4>
                            <p>In-Memory Cache</p>
                            <div class="component-cost">$40/mo</div>
                        </div>
                        <div class="enhanced-tooltip">
                            <h4>Redis Cache</h4>
                            <p>High-performance in-memory data store</p>
                            <p><strong>Use Cases:</strong> Caching, session storage, real-time data</p>
                            <p class="cost">Cost: $40/month</p>
                        </div>
                    </div>
                    <div class="component-item" draggable="true" data-component="mongodb" data-cost="60" onclick="showComponentInfo('mongodb')">
                        <i class="fas fa-leaf component-icon"></i>
                        <div class="component-info">
                            <h4>MongoDB</h4>
                            <p>NoSQL Database</p>
                            <div class="component-cost">$60/mo</div>
                        </div>
                        <div class="enhanced-tooltip">
                            <h4>MongoDB</h4>
                            <p>Document-oriented NoSQL database</p>
                            <p><strong>Use Cases:</strong> Content management, user profiles, analytics</p>
                            <p class="cost">Cost: $60/month</p>
                        </div>
                    </div>
                    <div class="component-item" draggable="true" data-component="kafka" data-cost="70" onclick="showComponentInfo('kafka')">
                        <i class="fas fa-stream component-icon"></i>
                        <div class="component-info">
                            <h4>Apache Kafka</h4>
                            <p>Message Queue</p>
                            <div class="component-cost">$70/mo</div>
                        </div>
                        <div class="enhanced-tooltip">
                            <h4>Apache Kafka</h4>
                            <p>Distributed streaming platform for real-time data</p>
                            <p><strong>Use Cases:</strong> Event streaming, microservices communication</p>
                            <p class="cost">Cost: $70/month</p>
                        </div>
                    </div>
                </div>

                <div class="component-category">
                    <div class="category-title">Security</div>
                    <div class="component-item" draggable="true" data-component="waf" data-cost="35" onclick="showComponentInfo('waf')">
                        <i class="fas fa-shield-alt component-icon"></i>
                        <div class="component-info">
                            <h4>Web Application Firewall</h4>
                            <p>Security Protection</p>
                            <div class="component-cost">$35/mo</div>
                        </div>
                        <div class="enhanced-tooltip">
                            <h4>Web Application Firewall</h4>
                            <p>Protects web applications from common attacks</p>
                            <p><strong>Use Cases:</strong> Security, DDoS protection, bot mitigation</p>
                            <p class="cost">Cost: $35/month</p>
                        </div>
                    </div>
                    <div class="component-item" draggable="true" data-component="cdn" data-cost="15" onclick="showComponentInfo('cdn')">
                        <i class="fas fa-globe component-icon"></i>
                        <div class="component-info">
                            <h4>CDN</h4>
                            <p>Content Delivery</p>
                            <div class="component-cost">$15/mo</div>
                        </div>
                        <div class="enhanced-tooltip">
                            <h4>Content Delivery Network</h4>
                            <p>Distributes content globally for faster access</p>
                            <p><strong>Use Cases:</strong> Static content, media delivery, performance</p>
                            <p class="cost">Cost: $15/month</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="workspace">
            <div class="performance-indicator good" id="performanceIndicator">
                <i class="fas fa-check-circle"></i>
                System Performance: Excellent
            </div>
            <div class="grid-overlay"></div>
            <div class="canvas" id="canvas">
                <div class="canvas-instruction">
                    <i class="fas fa-mouse-pointer"></i>
                    <span>Click components to add connection points, drag to other components</span>
                </div>
                <!-- Dropped components will appear here -->
            </div>
            <div class="zoom-controls">
                <button class="zoom-btn" onclick="zoomIn()" title="Zoom In">
                    <i class="fas fa-plus"></i>
                </button>
                <button class="zoom-btn" onclick="zoomOut()" title="Zoom Out">
                    <i class="fas fa-minus"></i>
                </button>
                <button class="zoom-btn" onclick="resetZoom()" title="Reset Zoom">
                    <i class="fas fa-expand-arrows-alt"></i>
                </button>
                <button class="zoom-btn" onclick="fitToScreen()" title="Fit to Screen">
                    <i class="fas fa-compress-arrows-alt"></i>
                </button>
            </div>
        </div>
    </div>

    <!-- Zoom Level Indicator -->
    <div class="zoom-level" id="zoomLevel">100%</div>

    <!-- Tool Mode Indicator -->
    <div class="tool-mode-indicator" id="toolModeIndicator">
        <i class="fas fa-hand-paper"></i>
        <span>Hand Mode Active - Click and drag to pan</span>
    </div>

    <div class="presentation-mode" id="presentationMode">
        <div class="presentation-content">
            <button class="presentation-close" onclick="togglePresentation()">
                <i class="fas fa-times"></i>
            </button>
            <div id="presentationCanvas"></div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <!-- Tutorial Overlay -->
    <div class="tutorial-overlay" id="tutorialOverlay">
        <div class="tutorial-content">
            <button class="tutorial-close" onclick="hideTutorial()">&times;</button>
            <div class="tutorial-step active" id="step1">
                <h2> Welcome to Architecture Simulator!</h2>
                <p>This tool helps you design and simulate software architectures with drag-and-drop components.</p>
                <div class="tutorial-navigation">
                    <button class="btn btn-secondary" onclick="hideTutorial()">Skip</button>
                    <button class="btn btn-primary" onclick="nextTutorialStep()">Next</button>
                </div>
            </div>
            <div class="tutorial-step" id="step2">
                <h2> Component Library</h2>
                <p>Drag components from the left sidebar to the canvas to build your architecture.</p>
                <div class="tutorial-navigation">
                    <button class="btn btn-secondary" onclick="prevTutorialStep()">Back</button>
                    <button class="btn btn-primary" onclick="nextTutorialStep()">Next</button>
                </div>
            </div>
            <div class="tutorial-step" id="step3">
                <h2> Simulation Features</h2>
                <p>Use the "Simulate" button to see data flow between components and monitor performance metrics.</p>
                <div class="tutorial-navigation">
                    <button class="btn btn-secondary" onclick="prevTutorialStep()">Back</button>
                    <button class="btn btn-primary" onclick="nextTutorialStep()">Next</button>
                </div>
            </div>
            <div class="tutorial-step" id="step4">
                <h2> Keyboard Shortcuts</h2>
                <p>Use Ctrl+Z to undo, Ctrl+Y to redo, Delete to remove selected components, and Ctrl+S to save.</p>
                <div class="tutorial-navigation">
                    <button class="btn btn-secondary" onclick="prevTutorialStep()">Back</button>
                    <button class="btn btn-primary" onclick="hideTutorial()">Get Started!</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Notification -->
    <div class="notification" id="notification"></div>

    <!-- Keyboard Shortcuts -->
    <div class="keyboard-shortcuts" id="keyboardShortcuts">
        <h4>Keyboard Shortcuts</h4>
        <div class="shortcut-item">
            <span>Undo</span>
            <span class="shortcut-key">Ctrl+Z</span>
        </div>
        <div class="shortcut-item">
            <span>Redo</span>
            <span class="shortcut-key">Ctrl+Y</span>
        </div>
        <div class="shortcut-item">
            <span>Delete</span>
            <span class="shortcut-key">Delete</span>
        </div>
        <div class="shortcut-item">
            <span>Save</span>
            <span class="shortcut-key">Ctrl+S</span>
        </div>
        <div class="shortcut-item">
            <span>Clear All</span>
            <span class="shortcut-key">Ctrl+Shift+C</span>
        </div>
        <div class="shortcut-item">
            <span>Simulate</span>
            <span class="shortcut-key">Space</span>
        </div>
        <div class="shortcut-item">
            <span>Hand Mode</span>
            <span class="shortcut-key">H</span>
        </div>
    </div>

    <!-- Auto-save Indicator -->
    <div class="auto-save-indicator" id="autoSaveIndicator">
        <i class="fas fa-save"></i> Auto-saved
    </div>

    <!-- Simulation Status -->
    <div class="simulation-status" id="simulationStatus">
        <i class="fas fa-play-circle"></i>
        <span id="simulationStatusText">Simulation Running...</span>
    </div>

    <!-- Mini Simulation Status -->
    <div class="simulation-mini" id="simulationMini">
        <i class="fas fa-cog fa-spin"></i>
        <span id="simulationMiniText">Simulating...</span>
    </div>

    <!-- Connection Info Panel -->
    <div class="connection-info" id="connectionInfo">
        <h3>Create Connection</h3>
        <form class="connection-form" id="connectionForm">
            <input type="text" id="connectionName" placeholder="Connection Name" required>
            <select id="connectionType">
                <option value="data">Data Flow</option>
                <option value="api">API Call</option>
                <option value="message">Message Queue</option>
                <option value="sync">Synchronization</option>
                <option value="auth">Authentication</option>
            </select>
            <textarea id="connectionDescription" placeholder="Connection Description (optional)"></textarea>
            <div class="connection-buttons">
                <button type="button" class="cancel-btn" onclick="cancelConnection()">Cancel</button>
                <button type="submit" class="save-btn">Create Connection</button>
            </div>
        </form>
    </div>

    <!-- Arrow Styling Panel -->
    <div class="arrow-styling-panel" id="arrowStylingPanel">
        <h3>Arrow Styling</h3>
        
        <div class="styling-section">
            <h4>Lebar Guratan</h4>
            <div class="styling-options">
                <div class="styling-option stroke-width-option thin" data-width="1">Tipis</div>
                <div class="styling-option stroke-width-option medium active" data-width="3">Sedang</div>
                <div class="styling-option stroke-width-option thick" data-width="5">Tebal</div>
            </div>
        </div>

        <div class="styling-section">
            <h4>Gaya Guratan</h4>
            <div class="styling-options">
                <div class="styling-option stroke-style-option solid active" data-style="solid">Solid</div>
                <div class="styling-option stroke-style-option dashed" data-style="dashed">Dashed</div>
                <div class="styling-option stroke-style-option dotted" data-style="dotted">Dotted</div>
            </div>
        </div>

        <div class="styling-section">
            <h4>Kecerobohan</h4>
            <div class="styling-options">
                <div class="styling-option roughness-option low active" data-roughness="0">Rendah</div>
                <div class="styling-option roughness-option medium" data-roughness="2">Sedang</div>
                <div class="styling-option roughness-option high" data-roughness="4">Tinggi</div>
            </div>
        </div>

        <div class="styling-section">
            <h4>Arrow Type</h4>
            <div class="styling-options">
                <div class="styling-option arrow-type-option straight" data-type="straight">Lurus</div>
                <div class="styling-option arrow-type-option curved active" data-type="curved">Melengkung</div>
                <div class="styling-option arrow-type-option right-angled" data-type="right-angled">Siku-siku</div>
            </div>
        </div>

        <div class="styling-section">
            <h4>Mata Panah</h4>
            <div class="styling-options">
                <div class="styling-option arrowhead-option line active" data-arrowhead="line">Garis</div>
                <div class="styling-option arrowhead-option triangle" data-arrowhead="triangle">Segitiga</div>
                <div class="styling-option arrowhead-option circle" data-arrowhead="circle">Lingkaran</div>
                <div class="styling-option arrowhead-option diamond" data-arrowhead="diamond">Diamond</div>
            </div>
        </div>
        
        <div class="styling-section" id="connectionEditorActions" style="display: none;">
            <div class="styling-options">
                <button class="styling-option" onclick="resetToGlobalStyle()" style="background: #f3f4f6; color: #374151;">
                    Reset ke Global
                </button>
                <button class="styling-option" onclick="closeConnectionEditor()" style="background: #ef4444; color: white;">
                    Tutup Editor
                </button>
            </div>
        </div>
    </div>

    <!-- Floating Arrow Style Panel (Excalidraw style) -->
    <div class="floating-arrow-panel" id="floatingArrowPanel">
        <h4>Style</h4>
        
        <div class="styling-section">
            <h4>Width</h4>
            <div class="styling-options">
                <div class="styling-option stroke-width-option thin" data-width="1">1</div>
                <div class="styling-option stroke-width-option medium active" data-width="3">3</div>
                <div class="styling-option stroke-width-option thick" data-width="5">5</div>
            </div>
        </div>

        <div class="styling-section">
            <h4>Style</h4>
            <div class="styling-options">
                <div class="styling-option stroke-style-option solid active" data-style="solid"></div>
                <div class="styling-option stroke-style-option dashed" data-style="dashed">- -</div>
                <div class="styling-option stroke-style-option dotted" data-style="dotted"> </div>
            </div>
        </div>

        <div class="styling-section">
            <h4>Type</h4>
            <div class="styling-options">
                <div class="styling-option arrow-type-option straight active" data-type="straight"></div>
                <div class="styling-option arrow-type-option curved" data-type="curved"></div>
                <div class="styling-option arrow-type-option right-angled" data-type="right-angled"></div>
            </div>
        </div>

        <div class="styling-section">
            <h4>Head</h4>
            <div class="styling-options">
                <div class="styling-option arrowhead-option line active" data-arrowhead="line"></div>
                <div class="styling-option arrowhead-option triangle" data-arrowhead="triangle"></div>
                <div class="styling-option arrowhead-option circle" data-arrowhead="circle"></div>
                <div class="styling-option arrowhead-option diamond" data-arrowhead="diamond"></div>
            </div>
        </div>
    </div>

    <!-- Connections List -->
    <div class="connections-list" id="connectionsList">
        <h4>Connections</h4>
        <div id="connectionsContainer">
            <!-- Connections will be added here dynamically -->
        </div>
    </div>

    <!-- Simulation Overlay -->
    <div class="simulation-overlay" id="simulationOverlay">
        <div class="simulation-panel">
            <button class="simulation-close" onclick="hideSimulationOverlay()">&times;</button>
            
            <div class="simulation-step active" id="simStep1">
                <h3> Starting Simulation</h3>
                <p>Analyzing your architecture components and preparing data flow simulation...</p>
                <div class="simulation-progress">
                    <div class="simulation-progress-bar" id="progressBar"></div>
                </div>
            </div>

            <div class="simulation-step" id="simStep2">
                <h3> Data Flow Analysis</h3>
                <p>Simulating how data moves between your components. Watch the blue particles flow!</p>
                <div class="simulation-progress">
                    <div class="simulation-progress-bar" id="progressBar2"></div>
                </div>
            </div>

            <div class="simulation-step" id="simStep3">
                <h3> Performance Testing</h3>
                <p>Testing component performance and identifying potential bottlenecks...</p>
                <div class="simulation-progress">
                    <div class="simulation-progress-bar" id="progressBar3"></div>
                </div>
            </div>

            <div class="simulation-step" id="simStep4">
                <h3> Simulation Complete</h3>
                <p>Your architecture simulation is complete! Check the metrics panel for detailed results.</p>
                <div class="simulation-controls">
                    <button class="btn btn-primary" onclick="hideSimulationOverlay()">
                        <i class="fas fa-check"></i> View Results
                    </button>
                    <button class="btn btn-secondary" onclick="restartSimulation()">
                        <i class="fas fa-redo"></i> Run Again
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Component Info Modal -->
    <div class="component-info-modal" id="componentInfoModal">
        <div class="component-info-content">
            <div class="component-info-header">
                <button class="component-info-close" onclick="hideComponentInfo()">&times;</button>
                <div class="component-info-title" id="modalTitle">
                    <i class="fas fa-info-circle"></i>
                    Component Information
                </div>
                <div class="component-info-subtitle" id="modalSubtitle">
                    Detailed information about this component
                </div>
            </div>
            <div class="component-info-body" id="modalBody">
                <!-- Content will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <script>
        let draggedElement = null;
        let droppedComponents = [];
        let componentCounter = 0;
        let isSimulating = false;
        let canvas = document.getElementById('canvas');
        let isHandMode = false;
        let totalCost = 0;
        let performanceScore = 100;
        let scalability = 'Good';
        let securityLevel = 'High';
        let undoStack = [];
        let redoStack = [];
        let currentTutorialStep = 1;
        let autoSaveInterval;
        let searchTimeout;
        
        // Zoom and pan variables
        let currentZoom = 1;
        let canvasOffset = { x: 0, y: 0 };
        let isPanning = false;
        let lastPanPoint = { x: 0, y: 0 };
        
        // Connection variables
        let connectingFrom = null;
        let connections = [];
        let connectionCounter = 0;

        // Arrow styling variables
        let arrowStyle = {
            strokeWidth: 3,
            strokeStyle: 'solid',
            roughness: 0,
            arrowType: 'curved',
            arrowhead: 'line'
        };

        // Initialize drag and drop
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize zoom and pan variables
            currentZoom = 1;
            canvasOffset = { x: 0, y: 0 };
            isPanning = false;
            lastPanPoint = { x: 0, y: 0 };
            
            initializeDragAndDrop();
            initializeKeyboardShortcuts();
            initializeSearch();
            initializeAutoSave();
            initializeArrowStyling();
            updateMetrics();
            
            // Initialize canvas transform
            canvas.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${currentZoom})`;
            canvas.style.transformOrigin = 'top left';
            
            // Initialize zoom level display
            const zoomLevelElement = document.getElementById('zoomLevel');
            if (zoomLevelElement) {
                zoomLevelElement.textContent = Math.round(currentZoom * 100) + '%';
            }
            
            showNotification('Welcome to Architecture Simulator! ', 'success');
        });

        function initializeDragAndDrop() {
            // Remove existing listeners to prevent duplicates
            canvas.removeEventListener('dragover', handleDragOver);
            canvas.removeEventListener('drop', handleDrop);
            canvas.removeEventListener('click', handleCanvasClick);
            
            // Add event listeners to canvas
            canvas.addEventListener('dragover', handleDragOver);
            canvas.addEventListener('drop', handleDrop);
            canvas.addEventListener('click', handleCanvasClick);
            
            // Initialize component items
            initializeComponentItems();
        }

        function initializeComponentItems() {
            const componentItems = document.querySelectorAll('.component-item');
            
            componentItems.forEach(item => {
                // Remove existing listeners
                item.removeEventListener('dragstart', handleDragStart);
                item.removeEventListener('dragend', handleDragEnd);
                
                // Add new listeners
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragend', handleDragEnd);
            });
        }

        function handleDragStart(e) {
            // Disable hand mode during drag
            if (isHandMode) {
                isHandMode = false;
                const handBtn = document.getElementById('handToolBtn');
                const toolIndicator = document.getElementById('toolModeIndicator');
                handBtn.classList.remove('active');
                canvas.classList.remove('hand-mode');
                toolIndicator.classList.remove('show');
            }
            
            draggedElement = e.target;
            e.target.style.opacity = '0.5';
        }

        function handleDragEnd(e) {
            e.target.style.opacity = '1';
            draggedElement = null;
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            if (!draggedElement) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const componentType = draggedElement.dataset.component;
            const componentCost = parseInt(draggedElement.dataset.cost);
            const componentName = draggedElement.querySelector('h4').textContent;
            const componentIcon = draggedElement.querySelector('.component-icon').className;

            createDroppedComponent(componentType, componentName, componentIcon, componentCost, x, y);
        }

        function createDroppedComponent(type, name, icon, cost, x, y) {
            // Save state for undo
            saveState();
            
            const component = document.createElement('div');
            component.className = 'dropped-component hand-drawn-shadow';
            component.style.left = x + 'px';
            component.style.top = y + 'px';
            component.dataset.type = type;
            component.dataset.cost = cost;
            component.id = 'component_' + (componentCounter++);
            component.dataset.id = component.id;

            component.innerHTML = `
                <div class="component-header">
                    <i class="${icon}"></i>
                    <span class="component-title">${name}</span>
                </div>
                <div class="component-cost-display">$${cost}/mo</div>
                <button class="delete-btn" onclick="deleteComponent(this.parentElement)"></button>
            `;

            component.addEventListener('mousedown', handleComponentMouseDown);
            component.addEventListener('click', handleComponentSelection);
            

            canvas.appendChild(component);
            droppedComponents.push(component);
            
            // Hide instruction text when components are added
            canvas.classList.add('has-components');
            
            // Add wobbly animation when component is created
            component.classList.add('wobbly');
            setTimeout(() => component.classList.remove('wobbly'), 500);
            
            updateMetrics();
            showNotification(`Added ${name} to architecture`, 'success');
        }

        function handleComponentMouseDown(e) {
            if (e.target.classList.contains('delete-btn')) return;
            
            const component = e.currentTarget;
            let isDragging = false;
            let startX = e.clientX;
            let startY = e.clientY;
            let startLeft = parseInt(component.style.left) || 0;
            let startTop = parseInt(component.style.top) || 0;
            const zoomLevel = currentZoom;
            
            // Check if this is a click (not a drag)
            let hasMoved = false;
            
            function handleMouseMove(e) {
                const deltaX = Math.abs(e.clientX - startX);
                const deltaY = Math.abs(e.clientY - startY);
                if (deltaX > 5 || deltaY > 5) {
                    hasMoved = true;
                    // Start drag logic
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Add dragging class for better performance
                    component.classList.add('dragging');
                    component.style.cursor = 'grabbing';
                    component.style.willChange = 'transform';
                    component.style.pointerEvents = 'none';
                    
                    // Throttle mousemove for better performance
                    let animationFrameId = null;
                    
                    function handleDragMove(e) {
                        if (animationFrameId) return;
                        
                        animationFrameId = requestAnimationFrame(() => {
                            e.preventDefault();
                            isDragging = true;
                            
                            const deltaX = (e.clientX - startX) / zoomLevel;
                            const deltaY = (e.clientY - startY) / zoomLevel;

                            // Update absolute position for real-time connection redraw
                            const newLeft = startLeft + deltaX;
                            const newTop = startTop + deltaY;
                            component.style.left = newLeft + 'px';
                            component.style.top = newTop + 'px';
                            component.style.transform = 'none';

                            // Redraw only connections related to this component
                            if (component.id) {
                                redrawConnectionsForComponent(component.id);
                            }
                            
                            // Update template connections
                            updateTemplateConnections();
                            
                            animationFrameId = null;
                        });
                    }
                    
                    function handleDragUp(e) {
                        e.preventDefault();
                        document.removeEventListener('mousemove', handleDragMove);
                        document.removeEventListener('mouseup', handleDragUp);
                        
                        if (animationFrameId) {
                            cancelAnimationFrame(animationFrameId);
                        }
                        
                        // Positions already updated during drag; ensure transform cleared
                        component.style.transform = 'none';
                        
                        component.classList.remove('dragging');
                        component.style.cursor = 'move';
                        component.style.willChange = 'auto';
                        component.style.pointerEvents = 'auto';
                        
                        if (isDragging) {
                            updateMetrics();
                            redrawConnections();
                        }
                    }
                    
                    document.addEventListener('mousemove', handleDragMove);
                    document.addEventListener('mouseup', handleDragUp);
                }
            }
            
            function handleMouseUp(e) {
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
                
                // If it's a click (not a drag), let the click event handle it
                if (!hasMoved) {
                    return;
                }
            }
            
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        }

        function handleComponentSelection(e) {
            e.stopPropagation();
            if (e.target.classList.contains('delete-btn')) return;
            
            const component = e.currentTarget;
            
            // Toggle connection mode for this component
            if (component.classList.contains('connecting')) {
                // Deactivate connection mode
                component.classList.remove('connecting');
                removeConnectionPointsFromComponent(component);
                hideSnapIndicator();
                connectingFrom = null;
                showNotification('Connection mode deactivated', 'info');
            } else {
                // Remove previous selection and connection modes
                document.querySelectorAll('.dropped-component').forEach(comp => {
                    comp.classList.remove('selected', 'connecting');
                    removeConnectionPointsFromComponent(comp);
                });
                
                // Activate connection mode for this component
                component.classList.add('connecting');
                addConnectionPointsToComponent(component);
                showNotification('Click and drag connection points to create connections', 'info');
            }
        }

        function handleCanvasClick(e) {
            // If clicking on an arrow, open its editor (delegation safety net)
            const arrowEl = e.target.closest('.connection-arrow');
            if (arrowEl && typeof connections !== 'undefined') {
                const idx = Array.from(document.querySelectorAll('.connection-arrow')).indexOf(arrowEl);
                const connection = connections[idx];
                if (connection) {
                    e.preventDefault();
                    e.stopPropagation();
                    document.querySelectorAll('.connection-arrow').forEach(a => a.classList.remove('selected'));
                    arrowEl.classList.add('selected');
                    openConnectionStyleEditor(connection, e);
                    return;
                }
            }

            // Deselect all components and remove connection modes when clicking on blank canvas
            document.querySelectorAll('.dropped-component').forEach(comp => {
                comp.classList.remove('selected', 'connecting');
                removeConnectionPointsFromComponent(comp);
            });
            hideSnapIndicator();
            connectingFrom = null;
        }

        function deleteComponent(component) {
            // Save state for undo
            saveState();
            
            // Remove connections related to this component
            const componentId = component.id;
            const relatedConnections = connections.filter(conn => 
                conn.from === componentId || conn.to === componentId
            );
            
            relatedConnections.forEach(connection => {
                if (connection.svgElement) {
                    connection.svgElement.remove();
                }
            });
            
            // Remove from connections array
            connections = connections.filter(conn => 
                conn.from !== componentId && conn.to !== componentId
            );
            
            // Update connections list
            updateConnectionsList();
            
            const index = droppedComponents.indexOf(component);
            if (index > -1) {
                droppedComponents.splice(index, 1);
            }
            component.remove();
            updateMetrics();
            showNotification('Component removed', 'warning');
        }

        function updateMetrics() {
            totalCost = droppedComponents.reduce((sum, comp) => sum + parseInt(comp.dataset.cost), 0);
            
            // Calculate performance score based on architecture
            let score = 100;
            if (droppedComponents.length === 0) score = 100;
            else if (droppedComponents.length < 3) score = 80;
            else if (droppedComponents.length < 6) score = 90;
            else score = 85;

            // Adjust based on component types
            const hasLoadBalancer = droppedComponents.some(comp => comp.dataset.type === 'load-balancer');
            const hasCache = droppedComponents.some(comp => comp.dataset.type === 'redis-cache');
            const hasCDN = droppedComponents.some(comp => comp.dataset.type === 'cdn');

            if (hasLoadBalancer) score += 5;
            if (hasCache) score += 5;
            if (hasCDN) score += 3;

            performanceScore = Math.min(100, score);

            // Update scalability
            if (droppedComponents.length < 3) scalability = 'Basic';
            else if (droppedComponents.length < 6) scalability = 'Good';
            else scalability = 'Excellent';

            // Update security level
            const hasWAF = droppedComponents.some(comp => comp.dataset.type === 'waf');
            const hasSecurity = droppedComponents.some(comp => 
                comp.dataset.type === 'waf' || comp.dataset.type === 'api-gateway'
            );
            
            if (hasWAF) securityLevel = 'Very High';
            else if (hasSecurity) securityLevel = 'High';
            else securityLevel = 'Medium';

            // Update UI
            document.getElementById('totalCost').textContent = `$${totalCost}`;
            document.getElementById('performanceScore').textContent = `${performanceScore}%`;
            document.getElementById('scalability').textContent = scalability;
            document.getElementById('securityLevel').textContent = securityLevel;
            
            // Update component count in sidebar
            document.getElementById('componentCount').textContent = droppedComponents.length;

            // Update performance indicator
            const indicator = document.getElementById('performanceIndicator');
            indicator.className = 'performance-indicator';
            if (performanceScore >= 90) {
                indicator.className += ' good';
                indicator.innerHTML = '<i class="fas fa-check-circle"></i> System Performance: Excellent';
            } else if (performanceScore >= 70) {
                indicator.className += ' warning';
                indicator.innerHTML = '<i class="fas fa-exclamation-triangle"></i> System Performance: Good';
            } else {
                indicator.className += ' danger';
                indicator.innerHTML = '<i class="fas fa-times-circle"></i> System Performance: Needs Improvement';
            }
        }

        window.simulateDataFlow = function() {
            if (isSimulating) return;
            
            const components = document.querySelectorAll('.dropped-component');
            
            if (components.length < 2) {
                showNotification('Please add at least 2 components to simulate data flow', 'warning');
                return;
            }

            // Start simulation
            isSimulating = true;
            showSimulationOverlay();
            startSimulationSteps();
        }

        function showSimulationOverlay() {
            document.getElementById('simulationOverlay').style.display = 'block';
            showSimulationMini('Starting simulation...');
        }

        function hideSimulationOverlay() {
            document.getElementById('simulationOverlay').style.display = 'none';
            hideSimulationMini();
        }

        function showSimulationStatus(message) {
            const status = document.getElementById('simulationStatus');
            const statusText = document.getElementById('simulationStatusText');
            statusText.textContent = message;
            status.classList.add('show');
        }

        function hideSimulationStatus() {
            document.getElementById('simulationStatus').classList.remove('show');
        }

        function showSimulationMini(message) {
            const mini = document.getElementById('simulationMini');
            const miniText = document.getElementById('simulationMiniText');
            miniText.textContent = message;
            mini.classList.add('show');
        }

        function hideSimulationMini() {
            document.getElementById('simulationMini').classList.remove('show');
        }

        function startSimulationSteps() {
            // Step 1: Starting Simulation
            showSimulationStep(1);
            updateProgressBar('progressBar', 25);
            showSimulationMini('Analyzing components...');
            
            setTimeout(() => {
                // Step 2: Data Flow Analysis
                showSimulationStep(2);
                updateProgressBar('progressBar2', 50);
                showSimulationMini('Simulating data flow...');
                createConnectionLines();
                startDataFlowAnimation();
                
                setTimeout(() => {
                    // Step 3: Performance Testing
                    showSimulationStep(3);
                    updateProgressBar('progressBar3', 75);
                    showSimulationMini('Testing performance...');
                    highlightComponents();
                    updateMetrics();
                    
                    setTimeout(() => {
                        // Step 4: Complete
                        showSimulationStep(4);
                        showSimulationMini('Simulation complete!');
                        isSimulating = false;
                        removeConnectionLines();
                        
                        // Auto-hide after 3 seconds
                        setTimeout(() => {
                            hideSimulationOverlay();
                        }, 3000);
                    }, 2000);
                }, 3000);
            }, 2000);
        }

        function showSimulationStep(stepNumber) {
            // Hide all steps
            document.querySelectorAll('.simulation-step').forEach(step => {
                step.classList.remove('active');
            });
            
            // Show current step
            document.getElementById(`simStep${stepNumber}`).classList.add('active');
        }

        function updateProgressBar(barId, percentage) {
            const progressBar = document.getElementById(barId);
            if (progressBar) {
                progressBar.style.width = percentage + '%';
            }
        }

        function createConnectionLines() {
            const canvas = document.getElementById('canvas');
            
            // Remove existing connection lines
            document.querySelectorAll('.connection-line').forEach(line => line.remove());
            
            // Only create lines for actual connections
            if (connections.length === 0) return;
            
            connections.forEach((connection, index) => {
                const fromComponent = document.getElementById(connection.from);
                if (!fromComponent) return;
                
                connection.targets.forEach((target, targetIndex) => {
                    const toComponent = document.getElementById(target.id);
                    if (!toComponent) return;
                    
                    const fromRect = fromComponent.getBoundingClientRect();
                    const toRect = toComponent.getBoundingClientRect();
                    const canvasRect = canvas.getBoundingClientRect();
                    
                    const startX = fromRect.left - canvasRect.left + fromRect.width / 2;
                    const startY = fromRect.top - canvasRect.top + fromRect.height / 2;
                    const endX = toRect.left - canvasRect.left + toRect.width / 2;
                    const endY = toRect.top - canvasRect.top + toRect.height / 2;
                    
                        const line = document.createElement('div');
                        line.className = 'connection-line';
                        line.style.left = Math.min(startX, endX) + 'px';
                        line.style.top = (startY + endY) / 2 + 'px';
                        line.style.width = Math.abs(endX - startX) + 'px';
                        line.style.transform = `rotate(${Math.atan2(endY - startY, endX - startX) * 180 / Math.PI}deg)`;
                        
                        canvas.appendChild(line);
                        
                        // Activate line with delay
                        setTimeout(() => {
                            line.classList.add('active');
                    }, (index + targetIndex) * 150);
                });
            });
        }

        function removeConnectionLines() {
            // Remove connection lines
            document.querySelectorAll('.connection-line').forEach(line => {
                line.classList.remove('active');
                setTimeout(() => line.remove(), 500);
            });
            
            // Remove data packets
            document.querySelectorAll('.data-packet').forEach(packet => {
                packet.remove();
            });
            
            // Remove data flow particles
            document.querySelectorAll('.data-flow').forEach(particle => {
                particle.remove();
            });
            
            // Remove flow indicators
            document.querySelectorAll('.flow-indicator').forEach(indicator => {
                indicator.remove();
            });
            
            // Remove data flow active class from components
            document.querySelectorAll('.data-flow-active').forEach(component => {
                component.classList.remove('data-flow-active');
            });
        }

        function startDataFlowAnimation() {
            console.log('Starting data flow animation...');
            
            // Use template connections if available, otherwise use regular connections
            const availableConnections = window.templateConnections && window.templateConnections.length > 0 
                ? window.templateConnections 
                : connections;
            
            if (availableConnections.length === 0) {
                console.log('No connections found. Please create connections between components first.');
                showNotification('No connections found. Please create connections between components first.', 'info');
                return;
            }
            
            // Find the starting component (component with no incoming connections)
            const startComponents = findStartingComponentsForTemplate();
            console.log('Starting components:', startComponents);
            
            if (startComponents.length === 0) {
                console.log('No starting components found. All components have incoming connections.');
                showNotification('No starting components found. All components have incoming connections.', 'info');
                return;
            }
            
            // Start data flow from each starting component
            startComponents.forEach((startComponent, index) => {
                setTimeout(() => {
                    console.log('Starting data flow from component:', startComponent.id);
                    animateDataFlowFromComponentTemplate(startComponent, []);
                }, index * 1000);
            });
        }

        function findStartingComponents() {
            const components = document.querySelectorAll('.dropped-component');
            const startComponents = [];
            
            components.forEach(component => {
                const componentId = component.id;
                // Check if this component has any incoming connections
                const hasIncomingConnections = connections.some(conn => 
                    conn.targets.some(target => target.id === componentId)
                );
                
                if (!hasIncomingConnections) {
                    startComponents.push(component);
                }
            });
            
            return startComponents;
        }

        function findStartingComponentsForTemplate() {
            const components = document.querySelectorAll('.dropped-component');
            const startComponents = [];
            
            components.forEach(component => {
                const componentId = component.id;
                // Check if this component has any incoming template connections
                const hasIncomingConnections = window.templateConnections && window.templateConnections.some(conn => 
                    conn.toComponent.id === componentId
                );
                
                if (!hasIncomingConnections) {
                    startComponents.push(component);
                }
            });
            
            return startComponents;
        }

        function animateDataFlowFromComponent(component, visited) {
            if (visited.includes(component.id)) {
                return; // Prevent infinite loops
            }
            
            visited.push(component.id);
            
            // Highlight the current component
            component.classList.add('data-flow-active');
                setTimeout(() => {
                component.classList.remove('data-flow-active');
            }, 1000);
            
            // Find all outgoing connections from this component
            const outgoingConnections = connections.filter(conn => 
                conn.from === component.id
            );
            
            if (outgoingConnections.length === 0) {
                return; // End of flow
            }
            
            // Animate data flow to each connected component
            outgoingConnections.forEach((connection, index) => {
                connection.targets.forEach((target, targetIndex) => {
                    setTimeout(() => {
                        const toComponent = document.getElementById(target.id);
                        if (toComponent) {
                            // Animate data packet along the connection
                            animateDataPacket(component, toComponent, connection);
                            
                            // Continue the flow from the target component
                            setTimeout(() => {
                                animateDataFlowFromComponent(toComponent, [...visited]);
                            }, 1500);
                        }
                    }, (index * 500) + (targetIndex * 200));
                });
            });
        }

        function animateDataFlowFromComponentTemplate(component, visited) {
            if (visited.includes(component.id)) {
                return; // Prevent infinite loops
            }
            
            visited.push(component.id);
            
            // Highlight the current component
            component.classList.add('data-flow-active');
            setTimeout(() => {
                component.classList.remove('data-flow-active');
            }, 1000);
            
            // Find all outgoing template connections from this component
            const outgoingConnections = window.templateConnections.filter(conn => 
                conn.fromComponent.id === component.id
            );
            
            if (outgoingConnections.length === 0) {
                return; // End of flow
            }
            
            // Animate data flow to each connected component
            outgoingConnections.forEach((connection, index) => {
                setTimeout(() => {
                    const toComponent = connection.toComponent;
                    if (toComponent) {
                        // Animate data packet along the connection
                        animateDataPacket(component, toComponent, connection);
                        
                        // Continue the flow from the target component
                        setTimeout(() => {
                            animateDataFlowFromComponentTemplate(toComponent, [...visited]);
                        }, 1500);
                    }
                }, index * 500);
            });
        }

        function animateDataPacket(fromComponent, toComponent, connection) {
            const canvas = document.getElementById('canvas');
            const canvasRect = canvas.getBoundingClientRect();
            const canvasTransform = canvas.style.transform;
            
            // Parse canvas transform
            const transformMatch = canvasTransform.match(/translate\(([^,]+)px,\s*([^)]+)px\)\s*scale\(([^)]+)\)/);
            const canvasOffsetX = transformMatch ? parseFloat(transformMatch[1]) : 0;
            const canvasOffsetY = transformMatch ? parseFloat(transformMatch[2]) : 0;
            const canvasScale = transformMatch ? parseFloat(transformMatch[3]) : 1;
            
            const fromRect = fromComponent.getBoundingClientRect();
            const toRect = toComponent.getBoundingClientRect();

            // Calculate positions in untransformed canvas space
            const fromX = (fromRect.left - canvasRect.left - canvasOffsetX) / canvasScale + (fromRect.width / canvasScale) / 2;
            const fromY = (fromRect.top - canvasRect.top - canvasOffsetY) / canvasScale + (fromRect.height / canvasScale) / 2;
            const toX = (toRect.left - canvasRect.left - canvasOffsetX) / canvasScale + (toRect.width / canvasScale) / 2;
            const toY = (toRect.top - canvasRect.top - canvasOffsetY) / canvasScale + (toRect.height / canvasScale) / 2;

            // Calculate connection points using proper edge detection
            const fromWidth = fromRect.width / canvasScale;
            const fromHeight = fromRect.height / canvasScale;
            const toWidth = toRect.width / canvasScale;
            const toHeight = toRect.height / canvasScale;
            
            const fromPoints = getComponentEdgePoints(fromX, fromY, fromWidth, fromHeight);
            const toPoints = getComponentEdgePoints(toX, toY, toWidth, toHeight);
            
            // Find best connection points
            const connectionPoints = findBestConnectionPoints(fromPoints, toPoints, fromX, fromY, toX, toY);
            
            const startX = connectionPoints.from.x;
            const startY = connectionPoints.from.y;
            const endX = connectionPoints.to.x;
            const endY = connectionPoints.to.y;

            // Determine data type based on component types
            const dataType = getDataTypeForConnection(fromComponent, toComponent);
            const iconClass = getIconForDataType(dataType);
            const packetColor = getColorForDataType(dataType);

            // Create data packet element
            const packet = document.createElement('div');
            packet.className = 'data-packet';
            packet.innerHTML = `<i class="${iconClass}"></i>`;
            packet.style.cssText = `
                position: absolute;
                left: ${startX}px;
                top: ${startY}px;
                width: 24px;
                height: 24px;
                background: ${packetColor};
                color: white;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 12px;
                z-index: 1000;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                animation: dataPacketPulse 0.6s ease-in-out infinite;
                transform: translate(-50%, -50%);
            `;

            canvas.appendChild(packet);

            // Animate the packet along the connection path
            const duration = 2500;
            const startTime = Date.now();

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Use easing function for smooth animation
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                const currentX = startX + (endX - startX) * easeProgress;
                const currentY = startY + (endY - startY) * easeProgress;
                
                packet.style.left = currentX + 'px';
                packet.style.top = currentY + 'px';
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Remove packet when animation completes
                    packet.remove();
                }
            }
            
            requestAnimationFrame(animate);
        }

        function getDataTypeForConnection(fromComponent, toComponent) {
            const fromType = fromComponent.dataset.type;
            const toType = toComponent.dataset.type;
            
            // Determine data type based on component types
            if (fromType === 'api-gateway' && toType === 'aws-lambda') {
                return 'request';
            } else if (fromType === 'aws-lambda' && toType === 'kafka') {
                return 'event';
            } else if (fromType === 'kafka' && (toType === 'mongodb' || toType === 'aws-rds')) {
                return 'data';
            } else if (fromType === 'aws-lambda' && toType === 'aws-rds') {
                return 'query';
            } else if (fromType === 'aws-lambda' && toType === 'mongodb') {
                return 'document';
            } else {
                return 'message';
            }
        }

        function getIconForDataType(dataType) {
            const icons = {
                'request': 'fas fa-paper-plane',
                'event': 'fas fa-bolt',
                'data': 'fas fa-database',
                'query': 'fas fa-search',
                'document': 'fas fa-file-alt',
                'message': 'fas fa-envelope'
            };
            return icons[dataType] || 'fas fa-circle';
        }

        function getColorForDataType(dataType) {
            const colors = {
                'request': 'linear-gradient(45deg, #3b82f6, #1d4ed8)',
                'event': 'linear-gradient(45deg, #f59e0b, #d97706)',
                'data': 'linear-gradient(45deg, #10b981, #059669)',
                'query': 'linear-gradient(45deg, #8b5cf6, #7c3aed)',
                'document': 'linear-gradient(45deg, #ef4444, #dc2626)',
                'message': 'linear-gradient(45deg, #06b6d4, #0891b2)'
            };
            return colors[dataType] || 'linear-gradient(45deg, #6b7280, #4b5563)';
        }

        function createDataFlowParticle() {
            const components = document.querySelectorAll('.dropped-component');
            if (components.length < 2) return;

            const fromComponent = components[Math.floor(Math.random() * components.length)];
            const toComponent = components[Math.floor(Math.random() * components.length)];
            
            if (fromComponent === toComponent) return;

            const fromRect = fromComponent.getBoundingClientRect();
            const toRect = toComponent.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect();

            const startX = fromRect.left - canvasRect.left + fromRect.width / 2;
            const startY = fromRect.top - canvasRect.top + fromRect.height / 2;
            const endX = toRect.left - canvasRect.left + toRect.width / 2;
            const endY = toRect.top - canvasRect.top + toRect.height / 2;

            const particle = document.createElement('div');
            particle.className = 'data-flow';
            particle.style.left = startX + 'px';
            particle.style.top = startY + 'px';
            canvas.appendChild(particle);

            // Add flow indicator
            const indicator = document.createElement('div');
            indicator.className = 'flow-indicator';
            indicator.textContent = 'Data';
            indicator.style.left = startX + 'px';
            indicator.style.top = (startY + endY) / 2 + 'px';
            canvas.appendChild(indicator);

            // Animate particle movement
            const duration = 2000;
            const startTime = Date.now();

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                const currentX = startX + (endX - startX) * progress;
                const currentY = startY + (endY - startY) * progress;
                
                particle.style.left = currentX + 'px';
                particle.style.top = currentY + 'px';
                indicator.style.left = currentX + 'px';
                indicator.style.top = currentY + 'px';
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    particle.remove();
                    indicator.remove();
                }
            }
            
            requestAnimationFrame(animate);
        }

        function highlightComponents() {
            const components = document.querySelectorAll('.dropped-component');
            components.forEach((component, index) => {
                setTimeout(() => {
                    component.classList.add('component-highlight');
                    setTimeout(() => {
                        component.classList.remove('component-highlight');
                    }, 1000);
                }, index * 200);
            });
        }

        function restartSimulation() {
            hideSimulationOverlay();
            setTimeout(() => {
                simulateDataFlow();
            }, 300);
        }


        window.exportArchitecture = function() {
            const architecture = {
                components: droppedComponents.map(comp => ({
                    type: comp.dataset.type,
                    cost: parseInt(comp.dataset.cost),
                    position: {
                        x: parseInt(comp.style.left),
                        y: parseInt(comp.style.top)
                    }
                })),
                metrics: {
                    totalCost,
                    performanceScore,
                    scalability,
                    securityLevel
                },
                timestamp: new Date().toISOString()
            };

            const dataStr = JSON.stringify(architecture, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = 'architecture-design.json';
            link.click();
            
            URL.revokeObjectURL(url);
        }

        window.togglePresentation = function() {
            const presentationMode = document.getElementById('presentationMode');
            const presentationCanvas = document.getElementById('presentationCanvas');
            
            if (presentationMode.style.display === 'none' || presentationMode.style.display === '') {
                presentationMode.style.display = 'block';
                presentationCanvas.innerHTML = canvas.innerHTML;
                presentationCanvas.style.transform = 'scale(1.2)';
                presentationCanvas.style.transition = 'transform 0.3s ease';
            } else {
                presentationMode.style.display = 'none';
            }
        }

        window.zoomIn = function() {
            try {
                console.log('zoomIn called, current zoom:', currentZoom);
                currentZoom = Math.min(currentZoom * 1.2, 3);
                console.log('new zoom:', currentZoom);
                updateZoom();
            } catch (error) {
                console.error('Error in zoomIn:', error);
            }
        }

        window.zoomOut = function() {
            try {
                console.log('zoomOut called, current zoom:', currentZoom);
                currentZoom = Math.max(currentZoom / 1.2, 0.3);
                console.log('new zoom:', currentZoom);
                updateZoom();
            } catch (error) {
                console.error('Error in zoomOut:', error);
            }
        }

        // Create global aliases for HTML onclick handlers
        function zoomIn() {
            window.zoomIn();
        }

        function zoomOut() {
            window.zoomOut();
        }

        window.resetZoom = function() {
            try {
                console.log('resetZoom called');
                currentZoom = 1;
                canvasOffset = { x: 0, y: 0 };
                
                // Reset canvas size for fixed positioning
                if (canvas.style.position === 'fixed') {
                    canvas.style.width = '';
                    canvas.style.height = '';
                    console.log('Canvas size reset to default');
                }
                
                updateZoom();
                console.log('resetZoom completed successfully');
            } catch (error) {
                console.error('Error in resetZoom:', error);
            }
        }

        // Create global aliases for HTML onclick handlers
        function resetZoom() {
            window.resetZoom();
        }

        window.fitToScreen = function() {
            console.log('fitToScreen called');
            const components = document.querySelectorAll('.dropped-component');
            console.log('Components found:', components.length);
            
            if (components.length === 0) {
                console.log('No components, resetting zoom');
                resetZoom();
                return;
            }

            // Calculate bounding box of all components
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            components.forEach(component => {
                const rect = component.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                const x = rect.left - canvasRect.left;
                const y = rect.top - canvasRect.top;
                
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x + rect.width);
                maxY = Math.max(maxY, y + rect.height);
            });

            console.log('Bounding box:', { minX, minY, maxX, maxY });

            // Calculate zoom to fit using canvas dimensions
            const canvasWidth = canvas.clientWidth;
            const canvasHeight = canvas.clientHeight;
            
            console.log('Canvas dimensions:', { canvasWidth, canvasHeight });
            
            const componentWidth = maxX - minX;
            const componentHeight = maxY - minY;
            
            // Add some padding
            const padding = 50;
            const scaleX = (canvasWidth - padding * 2) / componentWidth;
            const scaleY = (canvasHeight - padding * 2) / componentHeight;
            currentZoom = Math.min(scaleX, scaleY, 1);
            
            console.log('Calculated zoom:', currentZoom);
            
            // For fixed positioning, we just need to center the view
            canvasOffset = { x: 0, y: 0 };
            
            updateZoom();
            console.log('fitToScreen completed');
        }

        // Create global alias for HTML onclick handlers
        function fitToScreen() {
            window.fitToScreen();
        }

        // Test function to verify fit to screen works
        function testFitToScreen() {
            console.log('Testing fit to screen...');
            console.log('Current zoom before:', currentZoom);
            fitToScreen();
            console.log('Current zoom after:', currentZoom);
        }

        // Comprehensive test function for hand mode
        function testHandMode() {
            console.log('=== HAND MODE COMPREHENSIVE TEST ===');
            console.log('Current hand mode:', isHandMode);
            console.log('Canvas element:', canvas);
            console.log('Canvas position:', canvas.style.position);
            console.log('Canvas left:', canvas.style.left);
            console.log('Canvas width:', canvas.style.width);
            console.log('Canvas top:', canvas.style.top);
            console.log('Canvas right:', canvas.style.right);
            console.log('Canvas bottom:', canvas.style.bottom);
            console.log('Canvas zIndex:', canvas.style.zIndex);
            console.log('Canvas cursor:', canvas.style.cursor);
            console.log('Is panning:', isPanning);
            console.log('Last pan point:', lastPanPoint);
            
            // Test event listeners
            console.log('Event listeners attached:', {
                mousedown: canvas.onmousedown !== null,
                mousemove: canvas.onmousemove !== null,
                mouseup: canvas.onmouseup !== null,
                mouseleave: canvas.onmouseleave !== null
            });
            
            // Test canvas background elements
            const gridOverlay = canvas.querySelector('.grid-overlay');
            const canvasInstruction = canvas.querySelector('.canvas-instruction');
            const performanceIndicator = canvas.querySelector('.performance-indicator');
            
            console.log('Canvas background elements:', {
                gridOverlay: gridOverlay ? 'Found' : 'Not found',
                canvasInstruction: canvasInstruction ? 'Found' : 'Not found',
                performanceIndicator: performanceIndicator ? 'Found' : 'Not found'
            });
            
            console.log('=== END TEST ===');
        }

        // Quick hand mode test
        function quickHandTest() {
            console.log('Quick hand mode test...');
            if (!isHandMode) {
                console.log('Activating hand mode...');
                toggleHandMode();
            }
            console.log('Hand mode active:', isHandMode);
            console.log('Try clicking and dragging on canvas background now!');
        }

        window.updateZoom = function() {
            try {
                console.log('updateZoom called with zoom:', currentZoom, 'offset:', canvasOffset);
                
                // Validate variables
                if (typeof currentZoom !== 'number' || isNaN(currentZoom)) {
                    console.warn('Invalid currentZoom, resetting to 1');
                    currentZoom = 1;
                }
                
                if (!canvasOffset || typeof canvasOffset.x !== 'number' || typeof canvasOffset.y !== 'number') {
                    console.warn('Invalid canvasOffset, resetting to {x: 0, y: 0}');
                    canvasOffset = { x: 0, y: 0 };
                }
                
                // Always combine panning and zoom in one transform
                canvas.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${currentZoom})`;
                canvas.style.transformOrigin = 'top left';
                
                const zoomLevelElement = document.getElementById('zoomLevel');
                if (zoomLevelElement) {
                    zoomLevelElement.textContent = Math.round(currentZoom * 100) + '%';
                }
                
                // Update template connections after zoom
                updateTemplateConnections();
                
                console.log('Transform applied:', canvas.style.transform);
                console.log('Zoom level updated to:', Math.round(currentZoom * 100) + '%');
            } catch (error) {
                console.error('Error in updateZoom:', error);
            }
        }

        // Add mouse wheel zoom with throttling
        let zoomAnimationFrame = null;
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            // Throttle zoom updates for better performance
            if (zoomAnimationFrame) return;
            
            zoomAnimationFrame = requestAnimationFrame(() => {
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                currentZoom = Math.max(0.1, Math.min(3, currentZoom * delta));
                updateZoom();
                zoomAnimationFrame = null;
            });
        });

        // Comprehensive Hand Mode System

        // Remove all existing event listeners
        canvas.removeEventListener('mousedown', canvas.mousedownHandler);
        canvas.removeEventListener('mousemove', canvas.mousemoveHandler);
        canvas.removeEventListener('mouseup', canvas.mouseupHandler);
        canvas.removeEventListener('mouseleave', canvas.mouseleaveHandler);

        // Create new comprehensive event handlers
        function handleCanvasMouseDown(e) {
            console.log('Canvas mousedown - Hand mode:', isHandMode, 'Button:', e.button, 'Target:', e.target);
            
            // Only handle left mouse button
            if (e.button !== 0) return;
            
            // Check if we're in hand mode
            if (isHandMode) {
                // Check if clicking on canvas background (not on components or buttons)
                const isBackground = e.target === canvas || 
                                   e.target.classList.contains('grid-overlay') ||
                                   e.target.classList.contains('canvas-instruction') ||
                                   e.target.classList.contains('performance-indicator');
                
                if (isBackground) {
                    isPanning = true;
                    lastPanPoint = { x: e.clientX, y: e.clientY };
                    canvas.style.cursor = 'grabbing';
                    console.log('Hand mode panning started');
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }
            }
            
            // Handle middle mouse or Ctrl+Left click for panning (even without hand mode)
            if (e.button === 1 || (e.button === 0 && e.ctrlKey)) {
                isPanning = true;
                lastPanPoint = { x: e.clientX, y: e.clientY };
                canvas.style.cursor = 'grabbing';
                console.log('Ctrl+Click panning started');
                e.preventDefault();
            }
        }

        // Throttle panning for better performance
        let panningAnimationFrame = null;
        
        function handleCanvasMouseMove(e) {
            if (isPanning) {
                e.preventDefault();
                
                // Throttle panning updates for better performance
                if (panningAnimationFrame) return;
                
                panningAnimationFrame = requestAnimationFrame(() => {
                    const deltaX = e.clientX - lastPanPoint.x;
                    const deltaY = e.clientY - lastPanPoint.y;
                    
                    // Always use transform for panning (works for both fixed and relative positioning)
                    canvasOffset.x += deltaX;
                    canvasOffset.y += deltaY;
                    
                    // Apply transform directly to canvas
                    canvas.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${currentZoom})`;
                    canvas.style.transformOrigin = 'top left';
                    
                    // Update template connections after panning
                    updateTemplateConnections();
                    
                    lastPanPoint = { x: e.clientX, y: e.clientY };
                    panningAnimationFrame = null;
                });
            } else if (isHandMode) {
                // Show grab cursor when hovering over canvas in hand mode
                canvas.style.cursor = 'grab';
            }
        }

        function handleCanvasMouseUp(e) {
            console.log('Canvas mouseup - Panning:', isPanning, 'Hand mode:', isHandMode);
            isPanning = false;
            
            // Cancel any pending panning animation frame
            if (panningAnimationFrame) {
                cancelAnimationFrame(panningAnimationFrame);
                panningAnimationFrame = null;
            }
            
            if (isHandMode) {
                canvas.style.cursor = 'grab';
            } else {
                canvas.style.cursor = 'default';
            }
        }

        function handleCanvasMouseLeave(e) {
            console.log('Canvas mouseleave - Panning:', isPanning, 'Hand mode:', isHandMode);
            isPanning = false;
            
            if (isHandMode) {
                canvas.style.cursor = 'grab';
            } else {
                canvas.style.cursor = 'default';
            }
        }

        // Add event listeners
        canvas.addEventListener('mousedown', handleCanvasMouseDown);
        canvas.addEventListener('mousemove', handleCanvasMouseMove);
        canvas.addEventListener('mouseup', handleCanvasMouseUp);
        canvas.addEventListener('mouseleave', handleCanvasMouseLeave);

        // Comprehensive Hand Mode functionality
        window.toggleHandMode = function() {
            isHandMode = !isHandMode;
            const handBtn = document.getElementById('handToolBtn');
            const toolIndicator = document.getElementById('toolModeIndicator');
            const mainContainer = document.querySelector('.main-container');
            
            console.log('Hand mode toggled:', isHandMode);
            
            if (isHandMode) {
                // Activate hand mode
                handBtn.classList.add('active');
                canvas.classList.add('hand-mode');
                mainContainer.classList.add('hand-mode');
                toolIndicator.classList.add('show');
                canvas.style.cursor = 'grab';
                
                // Ensure canvas positioning is correct
                canvas.style.left = '320px';
                canvas.style.width = 'calc(100vw - 320px)';
                canvas.style.position = 'fixed';
                canvas.style.top = '80px';
                canvas.style.right = '0';
                canvas.style.bottom = '0';
                canvas.style.zIndex = '2'; // Above workspace but below sidebar
                
                // Initialize canvas transform for panning
                canvas.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${currentZoom})`;
                canvas.style.transformOrigin = 'top left';
                
                // Disable component dragging
                document.querySelectorAll('.dropped-component').forEach(component => {
                    component.style.pointerEvents = 'none';
                });
                
                // Show tool indicator
                showToolIndicator();
                
                console.log('Hand mode activated - Canvas ready for panning');
                console.log('Initial transform:', canvas.style.transform);
            } else {
                // Deactivate hand mode
                handBtn.classList.remove('active');
                canvas.classList.remove('hand-mode');
                mainContainer.classList.remove('hand-mode');
                toolIndicator.classList.remove('show');
                canvas.style.cursor = 'default';
                
                // Re-enable component dragging
                document.querySelectorAll('.dropped-component').forEach(component => {
                    component.style.pointerEvents = 'auto';
                });
                
                console.log('Hand mode deactivated - Component dragging enabled');
            }
        }


        // Connection Points System

        function removeConnectionPoints() {
            document.querySelectorAll('.connection-point').forEach(point => {
                point.remove();
            });
        }

        function removeConnectionPointsFromComponent(component) {
            const points = component.querySelectorAll('.connection-point');
            points.forEach(point => {
                point.remove();
            });
        }

        function addConnectionPointsToComponent(component) {
            const positions = ['top', 'right', 'bottom', 'left'];
            
            positions.forEach(position => {
                const point = document.createElement('div');
                point.className = `connection-point ${position}`;
                point.dataset.position = position;
                point.dataset.componentId = component.id;
                
                // Add drag event listeners
                point.addEventListener('mousedown', handleConnectionPointMouseDown);
                
                component.appendChild(point);
            });
        }

        function handleConnectionPointMouseDown(e) {
            e.stopPropagation();
            e.preventDefault();
            
            const point = e.currentTarget;
            const component = point.closest('.dropped-component');
            
            // Store connection data
            connectingFrom = {
                component: component,
                point: point,
                position: point.dataset.position
            };
            
            point.classList.add('dragging');
            
            // Create temporary connection line overlaying the whole canvas
            const tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            tempLine.classList.add('temp-connection-line');
            tempLine.style.position = 'absolute';
            tempLine.style.pointerEvents = 'none';
            tempLine.style.zIndex = '1100';
            tempLine.style.left = '0';
            tempLine.style.top = '0';
            tempLine.style.width = '100%';
            tempLine.style.height = '100%';
            // Match canvas size for absolute coordinates
            const cw = canvas.clientWidth || canvas.offsetWidth;
            const ch = canvas.clientHeight || canvas.offsetHeight;
            tempLine.setAttribute('viewBox', `0 0 ${cw} ${ch}`);
            tempLine.setAttribute('preserveAspectRatio', 'none');
            canvas.appendChild(tempLine);
            
            // Add mouse move and up listeners
            document.addEventListener('mousemove', handleConnectionPointMouseMove);
            document.addEventListener('mouseup', handleConnectionPointMouseUp);
            
            showNotification('Drag to another component to create connection', 'info');
        }

        function handleConnectionPointMouseMove(e) {
            if (!connectingFrom) return;
            
            const point = connectingFrom.point;
            const component = connectingFrom.component;
            const position = connectingFrom.position;
            
            // Calculate start position using the same logic as getConnectionPointPosition
            const componentX = parseFloat(component.style.left) || 0;
            const componentY = parseFloat(component.style.top) || 0;
            const componentWidth = component.getBoundingClientRect().width;
            const componentHeight = component.getBoundingClientRect().height;
            
            let startX, startY;
            switch (position) {
                case 'top':
                    startX = componentX + componentWidth / 2;
                    startY = componentY;
                    break;
                case 'right':
                    startX = componentX + componentWidth;
                    startY = componentY + componentHeight / 2;
                    break;
                case 'bottom':
                    startX = componentX + componentWidth / 2;
                    startY = componentY + componentHeight;
                    break;
                case 'left':
                    startX = componentX;
                    startY = componentY + componentHeight / 2;
                    break;
                default:
                    startX = componentX + componentWidth / 2;
                    startY = componentY + componentHeight / 2;
            }
            
            // Get mouse position relative to canvas
            const canvasRect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - canvasRect.left;
            const mouseY = e.clientY - canvasRect.top;
            
            // Update temporary line (full-canvas coordinates)
            const tempLine = document.querySelector('.temp-connection-line');
            if (tempLine) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', `M ${startX} ${startY} L ${mouseX} ${mouseY}`);
                path.setAttribute('stroke', '#3b82f6');
                path.setAttribute('stroke-width', '3');
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke-dasharray', '8,4');
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('stroke-linejoin', 'round');
                tempLine.innerHTML = '';
                tempLine.appendChild(path);
            }
            
            // Check for hover over other components (ignore overlays)
            const hoveredComponent = findHoveredComponent(mouseX, mouseY);
            if (hoveredComponent && hoveredComponent !== component) {
                // Show connection points on hovered component
                showConnectionPointsOnComponent(hoveredComponent);
                hideSnapIndicator();
            } else {
                // Hide connection points from all components except the source
                hideConnectionPointsFromAllComponents(component);
                hideSnapIndicator();
            }
        }

        function handleConnectionPointMouseUp(e) {
            if (!connectingFrom) return;
            
            const point = connectingFrom.point;
            const component = connectingFrom.component;
            
            // Remove dragging class
            point.classList.remove('dragging');
            
            // Remove temporary line
            const tempLine = document.querySelector('.temp-connection-line');
            if (tempLine) {
                tempLine.remove();
            }
            
            // Check for snap target
            const canvasRect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - canvasRect.left;
            const mouseY = e.clientY - canvasRect.top;
            const snapTarget = findSnapTarget(mouseX, mouseY);
            
            if (snapTarget && snapTarget.component !== component) {
                // Create connection
                createConnectionFromPoints(connectingFrom, snapTarget);
                showNotification('Connection created successfully!', 'success');
            } else {
                // Cancel connection
                showNotification('Connection cancelled', 'info');
            }
            
            // Clean up
            connectingFrom = null;
            hideSnapIndicator();
            
            // Hide all connection points and remove target classes
            document.querySelectorAll('.dropped-component').forEach(comp => {
                removeConnectionPointsFromComponent(comp);
                comp.classList.remove('connection-target');
            });
            
            // Remove event listeners
            document.removeEventListener('mousemove', handleConnectionPointMouseMove);
            document.removeEventListener('mouseup', handleConnectionPointMouseUp);
        }

        function findHoveredComponent(x, y) {
            const components = document.querySelectorAll('.dropped-component');
            for (let component of components) {
                // Use the same positioning logic as other functions
                const componentX = parseFloat(component.style.left) || 0;
                const componentY = parseFloat(component.style.top) || 0;
                const componentWidth = component.getBoundingClientRect().width;
                const componentHeight = component.getBoundingClientRect().height;
                
                if (x >= componentX && x <= componentX + componentWidth &&
                    y >= componentY && y <= componentY + componentHeight) {
                    return component;
                }
            }
            return null;
        }

        function showConnectionPointsOnComponent(component) {
            // Remove existing connection points from this component
            removeConnectionPointsFromComponent(component);
            
            // Add connection points to this component
            addConnectionPointsToComponent(component);
            
            // Add special class for visual feedback
            component.classList.add('connection-target');
        }

        function hideConnectionPointsFromAllComponents(sourceComponent) {
            document.querySelectorAll('.dropped-component').forEach(comp => {
                if (comp !== sourceComponent) {
                    removeConnectionPointsFromComponent(comp);
                    comp.classList.remove('connection-target');
                }
            });
        }

        function findSnapTarget(x, y) {
            const snapDistance = 30;
            let closestTarget = null;
            let closestDistance = Infinity;
            
            document.querySelectorAll('.connection-point').forEach(point => {
                if (point.classList.contains('dragging')) return;
                
                const component = point.closest('.dropped-component');
                const position = point.dataset.position;
                
                // Use the same positioning logic as getConnectionPointPosition
                const componentX = parseFloat(component.style.left) || 0;
                const componentY = parseFloat(component.style.top) || 0;
                const componentWidth = component.getBoundingClientRect().width;
                const componentHeight = component.getBoundingClientRect().height;
                
                let pointX, pointY;
                switch (position) {
                    case 'top':
                        pointX = componentX + componentWidth / 2;
                        pointY = componentY;
                        break;
                    case 'right':
                        pointX = componentX + componentWidth;
                        pointY = componentY + componentHeight / 2;
                        break;
                    case 'bottom':
                        pointX = componentX + componentWidth / 2;
                        pointY = componentY + componentHeight;
                        break;
                    case 'left':
                        pointX = componentX;
                        pointY = componentY + componentHeight / 2;
                        break;
                    default:
                        pointX = componentX + componentWidth / 2;
                        pointY = componentY + componentHeight / 2;
                }
                
                const distance = Math.sqrt((x - pointX) ** 2 + (y - pointY) ** 2);
                
                if (distance < snapDistance && distance < closestDistance) {
                    closestDistance = distance;
                    closestTarget = {
                        component: component,
                        point: point,
                        position: position,
                        x: pointX,
                        y: pointY
                    };
                }
            });
            
            return closestTarget;
        }

        function showSnapIndicator(target) {
            hideSnapIndicator();
            
            const indicator = document.createElement('div');
            indicator.className = 'snap-indicator';
            indicator.id = 'snapIndicator';
            
            // Use the calculated position from findSnapTarget
            indicator.style.left = (target.x - 12) + 'px';
            indicator.style.top = (target.y - 12) + 'px';
            
            canvas.appendChild(indicator);
        }

        function hideSnapIndicator() {
            const indicator = document.getElementById('snapIndicator');
            if (indicator) {
                indicator.remove();
            }
        }

        function createConnectionFromPoints(fromData, toData) {
            // Check if there's already a connection from this source
            const existingConnection = connections.find(conn => 
                conn.from === fromData.component.id && 
                conn.fromPosition === fromData.position
            );
            
            if (existingConnection) {
                console.log('Found existing connection, adding new target:', existingConnection);
                // Add new target to existing connection
                const newTarget = {
                    id: toData.component.id,
                    position: toData.position
                };
                
                // Check if target already exists
                const targetExists = existingConnection.targets.some(target => 
                    target.id === toData.component.id && target.position === toData.position
                );
                
                if (!targetExists) {
                    existingConnection.targets.push(newTarget);
                    console.log('Added new target, connection now has:', existingConnection.targets);
                    showNotification(`Added target to existing connection "${existingConnection.name}"`, 'success');
                    
                    // Redraw the connection with new target
                    redrawConnection(existingConnection);
                    updateConnectionsList();
                } else {
                    showNotification('This target is already connected', 'warning');
                }
                return;
            }
            
            // Create new connection object with multiple targets support
            const connection = {
                id: 'conn_' + (++connectionCounter),
                from: fromData.component.id,
                fromPosition: fromData.position,
                targets: [{
                    id: toData.component.id,
                    position: toData.position
                }],
                name: `Connection ${connectionCounter}`,
                type: 'data',
                description: '',
                created: new Date().toISOString(),
                style: {
                    strokeWidth: 3,
                    strokeStyle: 'solid',
                    roughness: 0,
                    arrowType: 'straight',
                    arrowhead: 'line'
                }
            };
            
            console.log('Creating new connection:', connection);
            
            // Add to connections array
            connections.push(connection);
            
            // Draw connection arrow immediately
            console.log('Creating connection:', connection);
            drawConnection(connection);
            
            // Update connections list
            updateConnectionsList();
            
            showNotification(`Connection "${connection.name}" created successfully!`, 'success');
        }


        window.cancelConnection = function() {
            const connectionInfo = document.getElementById('connectionInfo');
            connectionInfo.style.display = 'none';
            connectingFrom = null;
            hideSnapIndicator();
        }

        // Arrow styling functions
        window.toggleArrowStyling = function() {
            const panel = document.getElementById('arrowStylingPanel');
            console.log('Toggle arrow styling panel:', panel);
            
            if (panel.classList.contains('show')) {
                panel.classList.remove('show');
                panel.style.display = 'none';
                console.log('Panel hidden');
            } else {
                panel.classList.add('show');
                panel.style.display = 'block';
                console.log('Panel shown');
                console.log('Panel position:', {
                    top: panel.style.top,
                    right: panel.style.right,
                    zIndex: panel.style.zIndex
                });
            }
        }

        // Individual connection style editor
        let currentEditingConnection = null;
        
        function openConnectionStyleEditor(connection, event) {
            currentEditingConnection = connection;
            
            // Hide main panel if open
            const mainPanel = document.getElementById('arrowStylingPanel');
            mainPanel.classList.remove('show');
            mainPanel.style.display = 'none';
            
            // Show floating panel
            const floatingPanel = document.getElementById('floatingArrowPanel');
            
            // Position floating panel near the arrow
            if (event) {
                const canvasRect = canvas.getBoundingClientRect();
                const x = event.clientX - canvasRect.left;
                const y = event.clientY - canvasRect.top;
                
                // Position panel near click point, but keep it within canvas bounds
                const panelWidth = 180;
                const panelHeight = 200;
                let panelX = x + 10;
                let panelY = y - panelHeight / 2;
                
                // Adjust if panel would go outside canvas
                if (panelX + panelWidth > canvasRect.width) {
                    panelX = x - panelWidth - 10;
                }
                if (panelY < 0) {
                    panelY = 10;
                }
                if (panelY + panelHeight > canvasRect.height) {
                    panelY = canvasRect.height - panelHeight - 10;
                }
                
                floatingPanel.style.left = panelX + 'px';
                floatingPanel.style.top = panelY + 'px';
            }
            
            // Set current values
            setFloatingPanelValues(connection.style);
            
            // Append a delete button in floating panel (if not exist)
            const fpEl = document.getElementById('floatingArrowPanel');
            let del = fpEl.querySelector('#deleteConnectionBtn');
            if (!del) {
                del = document.createElement('button');
                del.id = 'deleteConnectionBtn';
                del.textContent = 'Delete';
                del.style.background = '#ef4444';
                del.style.color = '#fff';
                del.style.border = 'none';
                del.style.borderRadius = '8px';
                del.style.padding = '8px 12px';
                del.style.cursor = 'pointer';
                del.style.fontSize = '12px';
                del.style.marginTop = '10px';
                fpEl.appendChild(del);
            }
            del.onclick = function(e) {
                e.preventDefault();
                e.stopPropagation();
                if (currentEditingConnection) {
                    deleteConnection(currentEditingConnection.id);
                }
                fpEl.classList.remove('show');
                fpEl.style.display = 'none';
            };
            
            // Show floating panel
            floatingPanel.classList.add('show');
            floatingPanel.style.display = 'block';
            
            console.log('Editing connection with floating panel:', connection);
        }

        window.resetToGlobalStyle = function() {
            if (!currentEditingConnection) return;
            
            // Reset connection style to global style
            currentEditingConnection.style = { ...arrowStyle };
            
            // Update panel values
            setPanelValues(currentEditingConnection.style);
            
            // Redraw connection
            redrawConnection(currentEditingConnection);
            
            showNotification('Style reset to global settings', 'info');
        }

        window.closeConnectionEditor = function() {
            currentEditingConnection = null;
            const panel = document.getElementById('arrowStylingPanel');
            const title = panel.querySelector('h3');
            const editorActions = document.getElementById('connectionEditorActions');
            
            // Reset panel title
            title.textContent = 'Arrow Styling';
            
            // Hide editor actions
            editorActions.style.display = 'none';
            
            // Set panel to global values
            setPanelValues(arrowStyle);
            
            showNotification('Connection editor closed', 'info');
        }
        
        function setPanelValues(style) {
            // Set stroke width
            const widthOptions = document.querySelectorAll('.stroke-width-option');
            widthOptions.forEach(option => {
                option.classList.remove('active');
                if (parseInt(option.dataset.width) === style.strokeWidth) {
                    option.classList.add('active');
                }
            });
            
            // Set stroke style
            const styleOptions = document.querySelectorAll('.stroke-style-option');
            styleOptions.forEach(option => {
                option.classList.remove('active');
                if (option.dataset.style === style.strokeStyle) {
                    option.classList.add('active');
                }
            });
            
            // Set roughness
            const roughnessOptions = document.querySelectorAll('.roughness-option');
            roughnessOptions.forEach(option => {
                option.classList.remove('active');
                if (parseInt(option.dataset.roughness) === style.roughness) {
                    option.classList.add('active');
                }
            });
            
            // Set arrow type
            const typeOptions = document.querySelectorAll('.arrow-type-option');
            typeOptions.forEach(option => {
                option.classList.remove('active');
                if (option.dataset.type === style.arrowType) {
                    option.classList.add('active');
                }
            });
            
            // Set arrowhead
            const arrowheadOptions = document.querySelectorAll('.arrowhead-option');
            arrowheadOptions.forEach(option => {
                option.classList.remove('active');
                if (option.dataset.arrowhead === style.arrowhead) {
                    option.classList.add('active');
                }
            });
        }

        function setFloatingPanelValues(style) {
            const floatingPanel = document.getElementById('floatingArrowPanel');
            
            // Set stroke width
            const widthOptions = floatingPanel.querySelectorAll('.stroke-width-option');
            widthOptions.forEach(option => {
                option.classList.remove('active');
                if (parseInt(option.dataset.width) === style.strokeWidth) {
                    option.classList.add('active');
                }
            });
            
            // Set stroke style
            const styleOptions = floatingPanel.querySelectorAll('.stroke-style-option');
            styleOptions.forEach(option => {
                option.classList.remove('active');
                if (option.dataset.style === style.strokeStyle) {
                    option.classList.add('active');
                }
            });
            
            // Set arrow type
            const typeOptions = floatingPanel.querySelectorAll('.arrow-type-option');
            typeOptions.forEach(option => {
                option.classList.remove('active');
                if (option.dataset.type === style.arrowType) {
                    option.classList.add('active');
                }
            });
            
            // Set arrowhead
            const arrowheadOptions = floatingPanel.querySelectorAll('.arrowhead-option');
            arrowheadOptions.forEach(option => {
                option.classList.remove('active');
                if (option.dataset.arrowhead === style.arrowhead) {
                    option.classList.add('active');
                }
            });
        }

        function initializeArrowStyling() {
            const panel = document.getElementById('arrowStylingPanel');
            const floatingPanel = document.getElementById('floatingArrowPanel');
            
            // Add event listeners to main panel
            panel.addEventListener('click', function(e) {
                const option = e.target.closest('.styling-option');
                if (!option) return;
                
                const section = option.closest('.styling-section');
                const options = section.querySelectorAll('.styling-option');
                
                // Remove active class from all options in this section
                options.forEach(opt => opt.classList.remove('active'));
                
                // Add active class to clicked option
                option.classList.add('active');
                
                // Update style based on whether we're editing individual connection or global
                if (currentEditingConnection) {
                    // Update individual connection style
                    if (section.querySelector('.stroke-width-option')) {
                        currentEditingConnection.style.strokeWidth = parseInt(option.dataset.width);
                    } else if (section.querySelector('.stroke-style-option')) {
                        currentEditingConnection.style.strokeStyle = option.dataset.style;
                    } else if (section.querySelector('.roughness-option')) {
                        currentEditingConnection.style.roughness = parseInt(option.dataset.roughness);
                    } else if (section.querySelector('.arrow-type-option')) {
                        currentEditingConnection.style.arrowType = option.dataset.type;
                    } else if (section.querySelector('.arrowhead-option')) {
                        currentEditingConnection.style.arrowhead = option.dataset.arrowhead;
                    }
                    
                    // Redraw only the specific connection
                    redrawConnection(currentEditingConnection);
                } else {
                    // Update global arrow style
                    if (section.querySelector('.stroke-width-option')) {
                        arrowStyle.strokeWidth = parseInt(option.dataset.width);
                    } else if (section.querySelector('.stroke-style-option')) {
                        arrowStyle.strokeStyle = option.dataset.style;
                    } else if (section.querySelector('.roughness-option')) {
                        arrowStyle.roughness = parseInt(option.dataset.roughness);
                    } else if (section.querySelector('.arrow-type-option')) {
                        arrowStyle.arrowType = option.dataset.type;
                    } else if (section.querySelector('.arrowhead-option')) {
                        arrowStyle.arrowhead = option.dataset.arrowhead;
                    }
                    
                    // Redraw all connections with new global style
                    redrawConnections();
                }
            });

            // Add event listeners to floating panel
            floatingPanel.addEventListener('click', function(e) {
                const option = e.target.closest('.styling-option');
                if (!option) return;
                
                e.stopPropagation();
                
                const section = option.closest('.styling-section');
                const options = section.querySelectorAll('.styling-option');
                
                // Remove active class from all options in this section
                options.forEach(opt => opt.classList.remove('active'));
                
                // Add active class to clicked option
                option.classList.add('active');
                
                // Update individual connection style
                if (currentEditingConnection) {
                    if (section.querySelector('.stroke-width-option')) {
                        currentEditingConnection.style.strokeWidth = parseInt(option.dataset.width);
                    } else if (section.querySelector('.stroke-style-option')) {
                        currentEditingConnection.style.strokeStyle = option.dataset.style;
                    } else if (section.querySelector('.arrow-type-option')) {
                        currentEditingConnection.style.arrowType = option.dataset.type;
                    } else if (section.querySelector('.arrowhead-option')) {
                        currentEditingConnection.style.arrowhead = option.dataset.arrowhead;
                    }
                    
                    // Redraw only the specific connection
                    redrawConnection(currentEditingConnection);
                }
            });

            // Auto-hide floating panel when clicking outside
            document.addEventListener('click', function(e) {
                if (!floatingPanel.contains(e.target) && !e.target.closest('.connection-arrow')) {
                    floatingPanel.classList.remove('show');
                    floatingPanel.style.display = 'none';
                    currentEditingConnection = null;
                }
            });
        }

        // Handle connection form submission
        document.getElementById('connectionForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            const connectionInfo = document.getElementById('connectionInfo');
            const fromId = connectionInfo.dataset.fromId;
            const toId = connectionInfo.dataset.toId;
            const fromPosition = connectionInfo.dataset.fromPosition;
            const toPosition = connectionInfo.dataset.toPosition;
            
            const name = document.getElementById('connectionName').value;
            const type = document.getElementById('connectionType').value;
            const description = document.getElementById('connectionDescription').value;
            
            // Create connection object with new structure
            const connection = {
                id: 'conn_' + (++connectionCounter),
                from: fromId,
                fromPosition: fromPosition,
                targets: [{
                    id: toId,
                    position: toPosition
                }],
                name: name,
                type: type,
                description: description,
                created: new Date().toISOString(),
                style: { ...arrowStyle }
            };
            
            // Add to connections array
            connections.push(connection);
            
            // Draw connection arrow
            drawConnection(connection);
            
            // Update connections list
            updateConnectionsList();
            
            // Hide form and reset
            connectionInfo.style.display = 'none';
            document.getElementById('connectionForm').reset();
            
            showNotification(`Connection "${name}" created successfully!`, 'success');
        });

        function drawConnection(connection) {
            console.log('drawConnection called with:', connection);
            
            const fromComponent = document.getElementById(connection.from);
            if (!fromComponent) {
                console.error('Source component not found:', connection.from);
                return;
            }
            
            // Handle both old format (single target) and new format (multiple targets)
            const targets = connection.targets || [{
                id: connection.to,
                position: connection.toPosition
            }];
            
            // Draw a line to each target
            console.log(`Drawing connection with ${targets.length} targets:`, targets);
            targets.forEach((target, index) => {
                const toComponent = document.getElementById(target.id);
                if (!toComponent) {
                    console.error('Target component not found:', target.id);
                    return;
                }
                
                console.log(`Drawing target ${index}:`, target);
                drawSingleConnection(connection, fromComponent, toComponent, target.position, index);
            });
        }
        
        function drawSingleConnection(connection, fromComponent, toComponent, toPosition, targetIndex) {
            const canvas = document.getElementById('canvas');
            const canvasRect = canvas.getBoundingClientRect();
            const canvasTransform = canvas.style.transform;
            
            // Parse canvas transform
            const transformMatch = canvasTransform.match(/translate\(([^,]+)px,\s*([^)]+)px\)\s*scale\(([^)]+)\)/);
            const canvasOffsetX = transformMatch ? parseFloat(transformMatch[1]) : 0;
            const canvasOffsetY = transformMatch ? parseFloat(transformMatch[2]) : 0;
            const canvasScale = transformMatch ? parseFloat(transformMatch[3]) : 1;
            
            const fromRect = fromComponent.getBoundingClientRect();
            const toRect = toComponent.getBoundingClientRect();

            // Calculate positions in untransformed canvas space
            const fromX = (fromRect.left - canvasRect.left - canvasOffsetX) / canvasScale + (fromRect.width / canvasScale) / 2;
            const fromY = (fromRect.top - canvasRect.top - canvasOffsetY) / canvasScale + (fromRect.height / canvasScale) / 2;
            const toX = (toRect.left - canvasRect.left - canvasOffsetX) / canvasScale + (toRect.width / canvasScale) / 2;
            const toY = (toRect.top - canvasRect.top - canvasOffsetY) / canvasScale + (toRect.height / canvasScale) / 2;

            // Calculate connection points using proper edge detection
            const fromWidth = fromRect.width / canvasScale;
            const fromHeight = fromRect.height / canvasScale;
            const toWidth = toRect.width / canvasScale;
            const toHeight = toRect.height / canvasScale;
            
            const fromPoints = getComponentEdgePoints(fromX, fromY, fromWidth, fromHeight);
            const toPoints = getComponentEdgePoints(toX, toY, toWidth, toHeight);
            
            // Find best connection points
            const connectionPoints = findBestConnectionPoints(fromPoints, toPoints, fromX, fromY, toX, toY);
            
            const fromPoint = { x: connectionPoints.from.x, y: connectionPoints.from.y };
            const toPoint = { x: connectionPoints.to.x, y: connectionPoints.to.y };
            
            // Use individual connection style or fallback to global style
            const style = connection.style || arrowStyle;
            
            console.log('Drawing connection from:', fromPoint, 'to:', toPoint);
            console.log('Using style:', style);
            
            // Create simple div-based arrow container (clickable)
            const arrow = document.createElement('div');
            arrow.classList.add('connection-arrow');
            arrow.style.position = 'absolute';
            arrow.style.pointerEvents = 'auto';
            arrow.style.zIndex = '100';
            arrow.style.border = 'none';
            arrow.style.background = 'transparent';
            arrow.dataset.connectionId = connection.id;
            arrow.dataset.targetIndex = targetIndex;
            arrow.setAttribute('role', 'button');
            
            // Calculate distance and angle (and apply neat offsets so line/arrowhead sit exactly on the edge)
            const rawDx = toPoint.x - fromPoint.x;
            const rawDy = toPoint.y - fromPoint.y;
            const rawDist = Math.max(1, Math.sqrt(rawDx * rawDx + rawDy * rawDy));
            const ux = rawDx / rawDist; // unit vector
            const uy = rawDy / rawDist;

            // Offsets: pull line slightly outside components, and keep arrowhead outside the target box
            const startOffset = 6;   // px away from source edge
            const headOffset = 6;    // px before target edge for arrowhead footprint (reduced for smaller arrowheads)
            const adjFrom = { x: fromPoint.x + ux * startOffset, y: fromPoint.y + uy * startOffset };
            const adjTo   = { x: toPoint.x   - ux * headOffset,  y: toPoint.y   - uy * headOffset  };

            const deltaX = adjTo.x - adjFrom.x;
            const deltaY = adjTo.y - adjFrom.y;
            const distance = Math.sqrt(Math.max(0, deltaX * deltaX + deltaY * deltaY));
            const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
            
            console.log('Arrow calculation:', { deltaX, deltaY, distance, angle });
            
            // Handle different arrow types
            let arrowWidth, arrowHeight, arrowLeft, arrowTop;
            
            if (style.arrowType === 'curved') {
                // For curved arrows, we need more space
                const controlX = (fromPoint.x + toPoint.x) / 2 + (Math.random() - 0.5) * 50 * style.roughness;
                const controlY = (fromPoint.y + toPoint.y) / 2 + (Math.random() - 0.5) * 50 * style.roughness;
                
                // Add padding for arrowhead (reduced for smaller arrowheads)
                const arrowheadPadding = 12;
                arrowWidth = Math.max(Math.abs(toPoint.x - fromPoint.x), Math.abs(controlX - fromPoint.x)) + 50 + arrowheadPadding;
                arrowHeight = Math.max(Math.abs(toPoint.y - fromPoint.y), Math.abs(controlY - fromPoint.y)) + 50 + arrowheadPadding;
                arrowLeft = Math.min(fromPoint.x, toPoint.x, controlX) - 25 - arrowheadPadding/2;
                arrowTop = Math.min(fromPoint.y, toPoint.y, controlY) - 25 - arrowheadPadding/2;
            } else if (style.arrowType === 'right-angled') {
                // For right-angled arrows
                const midX = fromPoint.x + (toPoint.x - fromPoint.x) / 2;
                // Add padding for arrowhead (reduced for smaller arrowheads)
                const arrowheadPadding = 12;
                arrowWidth = Math.abs(toPoint.x - fromPoint.x) + arrowheadPadding;
                arrowHeight = Math.abs(toPoint.y - fromPoint.y) + arrowheadPadding;
                arrowLeft = Math.min(fromPoint.x, toPoint.x) - arrowheadPadding/2;
                arrowTop = Math.min(fromPoint.y, toPoint.y) - arrowheadPadding/2;
            } else {
                // Straight arrows  use bounding box so SVG path is never clipped
                // Add padding for arrowhead (8px width + 4px height + 4px margin)
                const arrowheadPadding = 12;
                const minX = Math.min(adjFrom.x, adjTo.x) - arrowheadPadding;
                const minY = Math.min(adjFrom.y, adjTo.y) - arrowheadPadding;
                const maxX = Math.max(adjFrom.x, adjTo.x) + arrowheadPadding;
                const maxY = Math.max(adjFrom.y, adjTo.y) + arrowheadPadding;
                arrowLeft = minX;
                arrowTop = minY;
                arrowWidth = Math.max(1, maxX - minX);
                arrowHeight = Math.max(style.strokeWidth + 40, maxY - minY);
            }
            
            // Position arrow
            arrow.style.left = arrowLeft + 'px';
            arrow.style.top = arrowTop + 'px';
            arrow.style.width = arrowWidth + 'px';
            arrow.style.height = arrowHeight + 'px';
            
            // Create line based on arrow type
            if (style.arrowType === 'curved') {
                // Create curved line using SVG
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.style.position = 'absolute';
                svg.style.width = '100%';
                svg.style.height = '100%';
                svg.style.left = '0';
                svg.style.top = '0';
                // allow clicking on the stroke only for curved
                svg.style.pointerEvents = 'auto';
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const controlX = (adjFrom.x - arrowLeft + adjTo.x - arrowLeft) / 2 + (Math.random() - 0.5) * 50 * style.roughness;
                const controlY = (adjFrom.y - arrowTop + adjTo.y - arrowTop) / 2 + (Math.random() - 0.5) * 50 * style.roughness;
                
                path.setAttribute('d', `M ${adjFrom.x - arrowLeft} ${adjFrom.y - arrowTop} Q ${controlX} ${controlY} ${adjTo.x - arrowLeft} ${adjTo.y - arrowTop}`);
                path.setAttribute('stroke', '#3b82f6');
                path.setAttribute('stroke-width', style.strokeWidth);
                path.setAttribute('fill', 'none');
                // dynamic marker based on head style
                const defsC = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                const markerC = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                const markerIdC = `arrowhead_${connection.id}_${targetIndex}`;
                markerC.setAttribute('id', markerIdC);
                markerC.setAttribute('markerWidth', '8');
                markerC.setAttribute('markerHeight', '8');
                markerC.setAttribute('refX', '7');
                markerC.setAttribute('refY', '4');
                markerC.setAttribute('orient', 'auto');
                markerC.setAttribute('markerUnits', 'strokeWidth');
                if (style.arrowhead === 'circle') {
                    const circ = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circ.setAttribute('cx', '4');
                    circ.setAttribute('cy', '4');
                    circ.setAttribute('r', '2.5');
                    circ.setAttribute('fill', '#3b82f6');
                    markerC.appendChild(circ);
                } else if (style.arrowhead === 'diamond') {
                    const dia = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    dia.setAttribute('d', 'M 4 0 L 8 4 L 4 8 L 0 4 Z');
                    dia.setAttribute('fill', '#3b82f6');
                    markerC.appendChild(dia);
                } else if (style.arrowhead === 'line') {
                    // No arrowhead - just a line
                    // Don't add any marker content
                } else {
                    const tri = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    tri.setAttribute('d', 'M 0 0 L 8 4 L 0 8 Z');
                    tri.setAttribute('fill', '#3b82f6');
                    markerC.appendChild(tri);
                }
                defsC.appendChild(markerC);
                svg.appendChild(defsC);
                if (style.arrowhead !== 'line') {
                    path.setAttribute('marker-end', `url(#${markerIdC})`);
                }
                
                // Apply stroke style
                if (style.strokeStyle === 'dashed') {
                    path.setAttribute('stroke-dasharray', '8,8');
                } else if (style.strokeStyle === 'dotted') {
                    path.setAttribute('stroke-dasharray', '4,4');
                }
                
                // make only the stroke clickable
                path.setAttribute('pointer-events', 'stroke');
                path.addEventListener('click', function(ev){
                    ev.preventDefault(); ev.stopPropagation();
                    openConnectionStyleEditor(connection, ev);
                });
                svg.appendChild(path);
                arrow.appendChild(svg);
                
            } else if (style.arrowType === 'right-angled') {
                // Orthogonal routing via SVG path with right angles
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.style.position = 'absolute'; svg.style.width = '100%'; svg.style.height = '100%'; svg.style.left = '0'; svg.style.top = '0'; svg.style.pointerEvents = 'auto';
                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                const markerId = `arrowhead_${connection.id}_${targetIndex}`; marker.setAttribute('id', markerId);
                marker.setAttribute('markerWidth', '8'); marker.setAttribute('markerHeight', '8'); marker.setAttribute('refX', '7'); marker.setAttribute('refY', '4'); marker.setAttribute('orient', 'auto'); marker.setAttribute('markerUnits', 'strokeWidth');
                if (style.arrowhead === 'circle') {
                    const circ = document.createElementNS('http://www.w3.org/2000/svg', 'circle'); circ.setAttribute('cx','4'); circ.setAttribute('cy','4'); circ.setAttribute('r','2.5'); circ.setAttribute('fill','#3b82f6'); marker.appendChild(circ);
                } else if (style.arrowhead === 'diamond') {
                    const dia = document.createElementNS('http://www.w3.org/2000/svg', 'path'); dia.setAttribute('d','M 4 0 L 8 4 L 4 8 L 0 4 Z'); dia.setAttribute('fill','#3b82f6'); marker.appendChild(dia);
                } else if (style.arrowhead === 'line') {
                    // No arrowhead - just a line
                    // Don't add any marker content
                } else {
                    const tri = document.createElementNS('http://www.w3.org/2000/svg', 'path'); tri.setAttribute('d','M 0 0 L 8 4 L 0 8 Z'); tri.setAttribute('fill','#3b82f6'); marker.appendChild(tri);
                }
                defs.appendChild(marker); svg.appendChild(defs);
                const path = document.createElementNS('http://www.w3.org/2000/svg','path');
                // Build L/Z route depending on side selection
                let p1x = adjFrom.x - arrowLeft, p1y = adjFrom.y - arrowTop;
                let p4x = adjTo.x - arrowLeft,   p4y = adjTo.y - arrowTop;
                let d;
                if (fromPosition === 'left' || fromPosition === 'right') {
                    const midX = (fromPosition === 'right') ? Math.min(p1x + Math.abs(p4x - p1x)/2, p4x) : Math.max(p1x - Math.abs(p4x - p1x)/2, p4x);
                    d = `M ${p1x} ${p1y} L ${midX} ${p1y} L ${midX} ${p4y} L ${p4x} ${p4y}`;
                } else {
                    const midY = (fromPosition === 'bottom') ? Math.min(p1y + Math.abs(p4y - p1y)/2, p4y) : Math.max(p1y - Math.abs(p4y - p1y)/2, p4y);
                    d = `M ${p1x} ${p1y} L ${p1x} ${midY} L ${p4x} ${midY} L ${p4x} ${p4y}`;
                }
                path.setAttribute('d', d);
                path.setAttribute('stroke','#3b82f6'); path.setAttribute('stroke-width', style.strokeWidth); path.setAttribute('fill','none');
                if (style.arrowhead !== 'line') {
                    path.setAttribute('marker-end',`url(#${markerId})`);
                }
                path.style.shapeRendering = 'geometricPrecision'; path.style.strokeLinecap = 'round'; path.style.strokeLinejoin = 'round';
                if (style.strokeStyle === 'dashed') { path.setAttribute('stroke-dasharray','8,8'); } else if (style.strokeStyle === 'dotted') { path.setAttribute('stroke-dasharray','4,4'); }
                path.setAttribute('pointer-events','stroke'); path.addEventListener('click', function(ev){ ev.preventDefault(); ev.stopPropagation(); openConnectionStyleEditor(connection, ev); });
                svg.appendChild(path); arrow.appendChild(svg);
            } else {
                // Straight line via SVG path + marker-end for pixel-perfect arrowhead
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.style.position = 'absolute';
                svg.style.width = '100%';
                svg.style.height = '100%';
                svg.style.left = '0';
                svg.style.top = '0';
                svg.style.pointerEvents = 'auto';

                const defs2 = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                const marker2 = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                const markerId2 = `arrowhead_${connection.id}_${targetIndex}`;
                marker2.setAttribute('id', markerId2);
                marker2.setAttribute('markerWidth', '8');
                marker2.setAttribute('markerHeight', '8');
                marker2.setAttribute('refX', '7');
                marker2.setAttribute('refY', '4');
                marker2.setAttribute('orient', 'auto');
                marker2.setAttribute('markerUnits', 'strokeWidth');
                if (style.arrowhead === 'circle') {
                    const circ2 = document.createElementNS('http://www.w3.org/2000/svg', 'circle'); circ2.setAttribute('cx','4'); circ2.setAttribute('cy','4'); circ2.setAttribute('r','2.5'); circ2.setAttribute('fill','#3b82f6'); marker2.appendChild(circ2);
                } else if (style.arrowhead === 'diamond') {
                    const dia2 = document.createElementNS('http://www.w3.org/2000/svg', 'path'); dia2.setAttribute('d','M 4 0 L 8 4 L 4 8 L 0 4 Z'); dia2.setAttribute('fill','#3b82f6'); marker2.appendChild(dia2);
                } else if (style.arrowhead === 'line') {
                    // No arrowhead - just a line
                    // Don't add any marker content
                } else {
                    const tri2 = document.createElementNS('http://www.w3.org/2000/svg', 'path'); tri2.setAttribute('d', 'M 0 0 L 8 4 L 0 8 Z'); tri2.setAttribute('fill', '#3b82f6'); marker2.appendChild(tri2);
                }
                defs2.appendChild(marker2);
                svg.appendChild(defs2);

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', `M ${adjFrom.x - arrowLeft} ${adjFrom.y - arrowTop} L ${adjTo.x - arrowLeft} ${adjTo.y - arrowTop}`);
                path.setAttribute('stroke', '#3b82f6');
                path.setAttribute('stroke-width', style.strokeWidth);
                path.setAttribute('fill', 'none');
                if (style.arrowhead !== 'line') {
                    path.setAttribute('marker-end', `url(#${markerId2})`);
                }
                if (style.strokeStyle === 'dashed') {
                    path.setAttribute('stroke-dasharray', '8,8');
                } else if (style.strokeStyle === 'dotted') {
                    path.setAttribute('stroke-dasharray', '4,4');
                }
                // Click on stroke
                path.setAttribute('pointer-events', 'stroke');
                path.addEventListener('click', function(ev){ ev.preventDefault(); ev.stopPropagation(); openConnectionStyleEditor(connection, ev); });
                svg.appendChild(path);
                arrow.appendChild(svg);
            }
            
            // Arrowhead is rendered via SVG marker-end for all types to avoid duplicates
            
            // Apply roughness effect to all lines
            if (style.roughness > 0) {
                arrow.style.filter = `blur(${style.roughness * 0.5}px)`;
                arrow.style.opacity = '0.9';
            }
            
            canvas.appendChild(arrow);
            
            // Store reference for deletion - use array for multiple arrows
            if (!connection.svgElements) {
                connection.svgElements = [];
            }
            connection.svgElements.push(arrow);
            
            // Add click event for individual styling (robust)
            arrow.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                console.log(' Arrow clicked  open style editor', connection.id);
                document.querySelectorAll('.connection-arrow').forEach(a => a.classList.remove('selected'));
                arrow.classList.add('selected');
                openConnectionStyleEditor(connection, e);
            });

            // Keyboard open (Enter) for accessibility when focused
            arrow.tabIndex = 0;
            arrow.addEventListener('keydown', function(e){
                if(e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    openConnectionStyleEditor(connection, e);
                }
            });
            
            // Add hover effect
            arrow.addEventListener('mouseenter', function() {
                arrow.style.cursor = 'pointer';
                arrow.style.opacity = '0.8';
            });
            
            arrow.addEventListener('mouseleave', function() {
                arrow.style.cursor = 'default';
                arrow.style.opacity = '1';
            });
            
            console.log('Simple arrow created successfully');
            console.log('Arrow element:', arrow);
            console.log('Canvas children count:', canvas.children.length);
        }

        function getConnectionPointPosition(component, position) {
            // Get component position relative to canvas (not viewport)
            const componentRect = component.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect();
            
            // Calculate component position within canvas
            const componentX = parseFloat(component.style.left) || 0;
            const componentY = parseFloat(component.style.top) || 0;
            const componentWidth = componentRect.width;
            const componentHeight = componentRect.height;
            
            // Calculate center position
            const centerX = componentX + componentWidth / 2;
            const centerY = componentY + componentHeight / 2;
            
            // Return position based on connection point
            switch (position) {
                case 'top':
                    return { 
                        x: centerX, 
                        y: componentY 
                    };
                case 'right':
                    return { 
                        x: componentX + componentWidth, 
                        y: centerY 
                    };
                case 'bottom':
                    return { 
                        x: centerX, 
                        y: componentY + componentHeight 
                    };
                case 'left':
                    return { 
                        x: componentX, 
                        y: centerY 
                    };
                default:
                    return { x: centerX, y: centerY };
            }
        }

        function updateConnectionsList() {
            const container = document.getElementById('connectionsContainer');
            container.innerHTML = '';
            
            connections.forEach(connection => {
                const item = document.createElement('div');
                item.classList.add('connection-item');
                
                // Handle both old format (single target) and new format (multiple targets)
                const targets = connection.targets || [{
                    id: connection.to,
                    position: connection.toPosition
                }];
                
                const targetCount = targets.length;
                const targetText = targetCount > 1 ? `${targetCount} targets` : '1 target';
                
                item.innerHTML = `
                    <span class="connection-label">${connection.name} (${connection.type}) - ${targetText}</span>
                    <button class="delete-btn" onclick="deleteConnection('${connection.id}')"></button>
                `;
                container.appendChild(item);
            });
        }

        window.deleteConnection = function(connectionId) {
            const connection = connections.find(c => c.id === connectionId);
            if (connection) {
                // Remove all arrows for this connection
                if (connection.svgElements) {
                    connection.svgElements.forEach(arrow => arrow.remove());
                } else if (connection.svgElement) {
                    connection.svgElement.remove();
                }
            }
            connections = connections.filter(c => c.id !== connectionId);
            updateConnectionsList();
            showNotification('Connection deleted.', 'info');
        }

        function redrawConnections() {
            // Remove all existing connection arrows
            document.querySelectorAll('.connection-arrow').forEach(arrow => {
                arrow.remove();
            });
            
            // Redraw all connections
            connections.forEach(connection => {
                drawConnection(connection);
            });
        }

        // Redraw only connections related to a component (for real-time dragging)
        function redrawConnectionsForComponent(componentId) {
            if (!connections || connections.length === 0) return;
            // Remove existing arrows linked to this component
            connections.forEach(connection => {
                const isRelated = connection.from === componentId || 
                    (connection.targets && connection.targets.some(target => target.id === componentId)) ||
                    connection.to === componentId; // backward compatibility
                
                if (isRelated) {
                    // Remove all arrows for this connection
                    if (connection.svgElements) {
                        connection.svgElements.forEach(arrow => arrow.remove());
                        connection.svgElements = [];
                    } else if (connection.svgElement) {
                        connection.svgElement.remove();
                    }
                    drawConnection(connection);
                }
            });
        }

        function redrawConnection(connection) {
            // Remove existing arrows for this connection
            if (connection.svgElements) {
                connection.svgElements.forEach(arrow => arrow.remove());
                connection.svgElements = [];
            } else if (connection.svgElement) {
                connection.svgElement.remove();
            }
            
            // Redraw the connection
            drawConnection(connection);
        }

        // Old event listeners removed - using new comprehensive system above

        // Auto-hide tool indicator after 3 seconds
        function showToolIndicator() {
            const toolIndicator = document.getElementById('toolModeIndicator');
            toolIndicator.classList.add('show');
            setTimeout(() => {
                toolIndicator.classList.remove('show');
            }, 3000);
        }

        // Add tooltip functionality
        document.addEventListener('mousemove', function(e) {
            const tooltip = document.getElementById('tooltip');
            const target = e.target;
            
            if (target.classList.contains('component-item')) {
                const cost = target.dataset.cost;
                tooltip.textContent = `Cost: $${cost}/month`;
                tooltip.style.display = 'block';
                tooltip.style.left = e.clientX + 10 + 'px';
                tooltip.style.top = e.clientY - 30 + 'px';
            } else {
                tooltip.style.display = 'none';
            }
        });

        // New functionality for better UX
        function initializeKeyboardShortcuts() {
            document.addEventListener('keydown', function(e) {
                if (e.ctrlKey) {
                    switch(e.key) {
                        case 'z':
                            e.preventDefault();
                            undo();
                            break;
                        case 'y':
                            e.preventDefault();
                            redo();
                            break;
                        case 's':
                            e.preventDefault();
                            exportArchitecture();
                            break;
                    }
                }
                
                if (e.ctrlKey && e.shiftKey && e.key === 'C') {
                    e.preventDefault();
                    clearCanvas();
                }
                
                if (e.key === 'Delete') {
                    deleteSelectedComponents();
                }
                
                if (e.key === ' ') {
                    e.preventDefault();
                    simulateDataFlow();
                }
                
                if (e.key === 'h' || e.key === 'H') {
                    e.preventDefault();
                    toggleHandMode();
                }
                
                
                if (e.key === 't' && e.ctrlKey) {
                    e.preventDefault();
                    testHandMode();
                }
                
                if (e.key === 'Escape') {
                    hideTutorial();
                    hideShortcuts();
                    if (isHandMode) {
                        toggleHandMode();
                    }
                }
            });
        }

        function initializeSearch() {
            const searchBox = document.getElementById('componentSearch');
            searchBox.addEventListener('input', function() {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    filterComponents(this.value);
                    // Re-initialize component items after filtering
                    initializeComponentItems();
                }, 300);
            });
        }

        function initializeAutoSave() {
            autoSaveInterval = setInterval(() => {
                autoSave();
            }, 30000); // Auto-save every 30 seconds
        }

        function filterComponents(searchTerm) {
            const components = document.querySelectorAll('.component-item');
            const term = searchTerm.toLowerCase();
            
            components.forEach(component => {
                const name = component.querySelector('h4').textContent.toLowerCase();
                const description = component.querySelector('p').textContent.toLowerCase();
                const category = component.closest('.component-category').querySelector('.category-title').textContent.toLowerCase();
                
                if (name.includes(term) || description.includes(term) || category.includes(term)) {
                    component.style.display = 'flex';
                } else {
                    component.style.display = 'none';
                }
            });
        }

        function saveState() {
            const state = {
                components: droppedComponents.map(comp => ({
                    type: comp.dataset.type,
                    cost: comp.dataset.cost,
                    id: comp.dataset.id,
                    position: {
                        x: parseInt(comp.style.left),
                        y: parseInt(comp.style.top)
                    }
                })),
                connections: connections.map(conn => ({
                    id: conn.id,
                    from: conn.from,
                    to: conn.to,
                    fromPosition: conn.fromPosition,
                    toPosition: conn.toPosition,
                    name: conn.name,
                    type: conn.type,
                    description: conn.description,
                    created: conn.created
                })),
                counter: componentCounter,
                connectionCounter: connectionCounter
            };
            
            undoStack.push(JSON.parse(JSON.stringify(state)));
            redoStack = []; // Clear redo stack when new action is performed
            
            // Limit undo stack size
            if (undoStack.length > 50) {
                undoStack.shift();
            }
        }

        function undo() {
            if (undoStack.length === 0) return;
            
            const currentState = {
                components: droppedComponents.map(comp => ({
                    type: comp.dataset.type,
                    cost: comp.dataset.cost,
                    id: comp.dataset.id,
                    position: {
                        x: parseInt(comp.style.left),
                        y: parseInt(comp.style.top)
                    }
                })),
                connections: connections.map(conn => ({
                    id: conn.id,
                    from: conn.from,
                    to: conn.to,
                    fromPosition: conn.fromPosition,
                    toPosition: conn.toPosition,
                    name: conn.name,
                    type: conn.type,
                    description: conn.description,
                    created: conn.created
                })),
                counter: componentCounter,
                connectionCounter: connectionCounter
            };
            
            redoStack.push(currentState);
            const previousState = undoStack.pop();
            restoreState(previousState);
            showNotification('Undo performed', 'success');
        }

        function redo() {
            if (redoStack.length === 0) return;
            
            const stateToRestore = redoStack.pop();
            undoStack.push({
                components: droppedComponents.map(comp => ({
                    type: comp.dataset.type,
                    cost: comp.dataset.cost,
                    id: comp.dataset.id,
                    position: {
                        x: parseInt(comp.style.left),
                        y: parseInt(comp.style.top)
                    }
                })),
                connections: connections.map(conn => ({
                    id: conn.id,
                    from: conn.from,
                    to: conn.to,
                    fromPosition: conn.fromPosition,
                    toPosition: conn.toPosition,
                    name: conn.name,
                    type: conn.type,
                    description: conn.description,
                    created: conn.created
                })),
                counter: componentCounter,
                connectionCounter: connectionCounter
            });
            restoreState(stateToRestore);
            showNotification('Redo performed', 'success');
        }

        function restoreState(state) {
            // Clear current components
            droppedComponents.forEach(comp => comp.remove());
            droppedComponents = [];
            
            // Clear current connections
            document.querySelectorAll('.connection-arrow').forEach(arrow => {
                arrow.remove();
            });
            connections = [];
            
            // Restore components
            state.components.forEach(compData => {
                const component = document.createElement('div');
                component.className = 'dropped-component';
                component.style.left = compData.position.x + 'px';
                component.style.top = compData.position.y + 'px';
                component.dataset.type = compData.type;
                component.dataset.cost = compData.cost;
                component.id = compData.id;
                component.dataset.id = compData.id;
                
                // Find original component data
                const originalComponent = document.querySelector(`[data-component="${compData.type}"]`);
                const name = originalComponent.querySelector('h4').textContent;
                const icon = originalComponent.querySelector('.component-icon').className;
                
                component.innerHTML = `
                    <div class="component-header">
                        <i class="${icon}"></i>
                        <span class="component-title">${name}</span>
                    </div>
                    <div class="component-cost-display">$${compData.cost}/mo</div>
                    <button class="delete-btn" onclick="deleteComponent(this.parentElement)"></button>
                `;
                
                component.addEventListener('mousedown', handleComponentMouseDown);
            component.addEventListener('click', handleComponentSelection);
                component.addEventListener('mousedown', handleComponentMouseDown);
                
                canvas.appendChild(component);
                droppedComponents.push(component);
            });
            
            // Restore connections
            if (state.connections) {
                connections = state.connections.map(conn => ({
                    id: conn.id,
                    from: conn.from,
                    to: conn.to,
                    fromPosition: conn.fromPosition,
                    toPosition: conn.toPosition,
                    name: conn.name,
                    type: conn.type,
                    description: conn.description,
                    created: conn.created
                }));
                
                // Redraw all connections
                connections.forEach(connection => {
                    drawConnection(connection);
                });
            }
            
            componentCounter = state.counter;
            if (state.connectionCounter) {
                connectionCounter = state.connectionCounter;
            }
            
            updateMetrics();
            updateConnectionsList();
            
        }

        function deleteSelectedComponents() {
            const selectedComponents = document.querySelectorAll('.dropped-component.selected');
            if (selectedComponents.length === 0) return;
            
            saveState();
            selectedComponents.forEach(comp => {
                const index = droppedComponents.indexOf(comp);
                if (index > -1) {
                    droppedComponents.splice(index, 1);
                }
                comp.remove();
            });
            updateMetrics();
            showNotification(`Deleted ${selectedComponents.length} component(s)`, 'warning');
        }

        window.clearCanvas = function() {
            if (droppedComponents.length === 0) return;
            
            if (confirm('Are you sure you want to clear all components?')) {
                saveState();
                
                // Remove all connections
                document.querySelectorAll('.connection-arrow').forEach(arrow => {
                    arrow.remove();
                });
                
                // Remove template connection lines
                document.querySelectorAll('.template-connection-line').forEach(line => {
                    line.remove();
                });
                
                // Remove template arrowheads
                document.querySelectorAll('.template-arrowhead').forEach(arrowhead => {
                    arrowhead.remove();
                });
                
                // Remove template connection SVGs
                document.querySelectorAll('.template-connection-svg').forEach(svg => {
                    svg.remove();
                });
                
                // Clear template connections array
                if (window.templateConnections) {
                    window.templateConnections = [];
                }
                
                connections = [];
                connectionCounter = 0;
                updateConnectionsList();
                
                // Remove all connection points
                removeConnectionPoints();
                
                droppedComponents.forEach(comp => comp.remove());
                droppedComponents = [];
                componentCounter = 0;
                
                // Show instruction text when canvas is cleared
                canvas.classList.remove('has-components');
                
                updateMetrics();
                showNotification('Canvas cleared', 'warning');
            }
        }

        window.loadTemplate = function(templateName) {
            // Disable hand mode when loading template
            if (isHandMode) {
                isHandMode = false;
                const handBtn = document.getElementById('handToolBtn');
                const toolIndicator = document.getElementById('toolModeIndicator');
                handBtn.classList.remove('active');
                canvas.classList.remove('hand-mode');
                toolIndicator.classList.remove('show');
            }
            
            clearCanvas();
            saveState();
            
            const templates = {
                'web-app': {
                    components: [
                        { type: 'load-balancer', name: 'Load Balancer', icon: 'fas fa-balance-scale', cost: 30, x: 300, y: 80 },
                        { type: 'aws-ec2', name: 'AWS EC2', icon: 'fab fa-aws', cost: 50, x: 200, y: 200 },
                        { type: 'aws-ec2', name: 'AWS EC2', icon: 'fab fa-aws', cost: 50, x: 400, y: 200 },
                        { type: 'aws-rds', name: 'AWS RDS', icon: 'fas fa-database', cost: 80, x: 300, y: 320 },
                        { type: 'redis-cache', name: 'Redis Cache', icon: 'fas fa-memory', cost: 40, x: 500, y: 320 }
                    ],
                    connections: [
                        { from: 0, to: [1, 2] }, // Load Balancer -> EC2 instances
                        { from: 1, to: [3, 4] }, // EC2 -> RDS & Redis
                        { from: 2, to: [3, 4] }  // EC2 -> RDS & Redis
                    ]
                },
                'microservices': {
                    components: [
                        { type: 'api-gateway', name: 'API Gateway', icon: 'fas fa-door-open', cost: 25, x: 300, y: 80 },
                        { type: 'aws-lambda', name: 'User Service', icon: 'fas fa-bolt', cost: 20, x: 150, y: 200 },
                        { type: 'aws-lambda', name: 'Order Service', icon: 'fas fa-bolt', cost: 20, x: 300, y: 200 },
                        { type: 'aws-lambda', name: 'Payment Service', icon: 'fas fa-bolt', cost: 20, x: 450, y: 200 },
                        { type: 'kafka', name: 'Apache Kafka', icon: 'fas fa-stream', cost: 70, x: 300, y: 320 },
                        { type: 'mongodb', name: 'MongoDB', icon: 'fas fa-leaf', cost: 60, x: 200, y: 440 },
                        { type: 'aws-rds', name: 'AWS RDS', icon: 'fas fa-database', cost: 80, x: 400, y: 440 }
                    ],
                    connections: [
                        { from: 0, to: [1, 2, 3] }, // API Gateway -> Services
                        { from: 1, to: [4] },       // User Service -> Kafka
                        { from: 2, to: [4] },       // Order Service -> Kafka
                        { from: 3, to: [4] },       // Payment Service -> Kafka
                        { from: 4, to: [5, 6] }     // Kafka -> Databases
                    ]
                },
                'serverless': {
                    components: [
                        { type: 'api-gateway', name: 'API Gateway', icon: 'fas fa-door-open', cost: 25, x: 300, y: 80 },
                        { type: 'aws-lambda', name: 'Lambda Function', icon: 'fas fa-bolt', cost: 20, x: 300, y: 200 },
                        { type: 'aws-lambda', name: 'Lambda Function', icon: 'fas fa-bolt', cost: 20, x: 200, y: 320 },
                        { type: 'aws-lambda', name: 'Lambda Function', icon: 'fas fa-bolt', cost: 20, x: 400, y: 320 },
                        { type: 'aws-rds', name: 'AWS RDS', icon: 'fas fa-database', cost: 80, x: 300, y: 440 }
                    ],
                    connections: [
                        { from: 0, to: [1] },       // API Gateway -> Main Lambda
                        { from: 1, to: [2, 3] },    // Main Lambda -> Other Lambdas
                        { from: 2, to: [4] },       // Lambda -> RDS
                        { from: 3, to: [4] }        // Lambda -> RDS
                    ]
                },
                'data-pipeline': {
                    components: [
                        { type: 'kafka', name: 'Apache Kafka', icon: 'fas fa-stream', cost: 70, x: 200, y: 80 },
                        { type: 'aws-lambda', name: 'Data Processor', icon: 'fas fa-bolt', cost: 20, x: 300, y: 200 },
                        { type: 'mongodb', name: 'MongoDB', icon: 'fas fa-leaf', cost: 60, x: 200, y: 320 },
                        { type: 'aws-rds', name: 'AWS RDS', icon: 'fas fa-database', cost: 80, x: 300, y: 320 },
                        { type: 'redis-cache', name: 'Redis Cache', icon: 'fas fa-memory', cost: 40, x: 400, y: 320 }
                    ],
                    connections: [
                        { from: 0, to: [1] },       // Kafka -> Data Processor
                        { from: 1, to: [2, 3, 4] }  // Data Processor -> All Databases
                    ]
                }
            };
            
            const template = templates[templateName];
            if (template) {
                // Create components
                template.components.forEach(comp => {
                    createDroppedComponent(comp.type, comp.name, comp.icon, comp.cost, comp.x, comp.y);
                });
                
                // Create connections after a short delay to ensure components are rendered
                setTimeout(() => {
                    createTemplateConnections(template.connections);
                }, 100);
                
                showNotification(`${templateName.replace('-', ' ')} template loaded with connections!`, 'success');
            }
        }

        function createTemplateConnections(connectionPatterns) {
            // Get all dropped components
            const components = document.querySelectorAll('.dropped-component');
            
            connectionPatterns.forEach(pattern => {
                const fromComponent = components[pattern.from];
                if (!fromComponent) return;
                
                pattern.to.forEach(targetIndex => {
                    const toComponent = components[targetIndex];
                    if (!toComponent) return;
                    
                    // Create simple connection line instead of complex arrow
                    createSimpleConnection(fromComponent, toComponent);
                });
            });
        }

        function createSimpleConnection(fromComponent, toComponent) {
            const canvas = document.getElementById('canvas');
            
            // Get component positions
            const fromRect = fromComponent.getBoundingClientRect();
            const toRect = toComponent.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect();
            const canvasTransform = canvas.style.transform;
            
            // Parse canvas transform
            const transformMatch = canvasTransform.match(/translate\(([^,]+)px,\s*([^)]+)px\)\s*scale\(([^)]+)\)/);
            const canvasOffsetX = transformMatch ? parseFloat(transformMatch[1]) : 0;
            const canvasOffsetY = transformMatch ? parseFloat(transformMatch[2]) : 0;
            const canvasScale = transformMatch ? parseFloat(transformMatch[3]) : 1;
            
            // Calculate positions in untransformed canvas space
            const fromX = (fromRect.left - canvasRect.left - canvasOffsetX) / canvasScale + (fromRect.width / canvasScale) / 2;
            const fromY = (fromRect.top - canvasRect.top - canvasOffsetY) / canvasScale + (fromRect.height / canvasScale) / 2;
            const toX = (toRect.left - canvasRect.left - canvasOffsetX) / canvasScale + (toRect.width / canvasScale) / 2;
            const toY = (toRect.top - canvasRect.top - canvasOffsetY) / canvasScale + (toRect.height / canvasScale) / 2;
            
            // Calculate connection points using proper edge detection
            const fromWidth = fromRect.width / canvasScale;
            const fromHeight = fromRect.height / canvasScale;
            const toWidth = toRect.width / canvasScale;
            const toHeight = toRect.height / canvasScale;
            
            const deltaX = toX - fromX;
            const deltaY = toY - fromY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            if (distance < 50) return; // Skip if components are too close
            
            // Calculate intersection points with component rectangles
            const fromPoints = getComponentEdgePoints(fromX, fromY, fromWidth, fromHeight);
            const toPoints = getComponentEdgePoints(toX, toY, toWidth, toHeight);
            
            // Find best connection points
            const connection = findBestConnectionPoints(fromPoints, toPoints, fromX, fromY, toX, toY);
            
            const startX = connection.from.x;
            const startY = connection.from.y;
            const endX = connection.to.x;
            const endY = connection.to.y;
            
            // Create connection object for tracking
            const connectionId = `conn_${fromComponent.id}_${toComponent.id}`;
            
            // Create SVG for better line rendering
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.className = 'template-connection-svg';
            svg.id = connectionId;
            svg.style.cssText = `
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 5;
            `;
            
            // Create line path
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', startX);
            line.setAttribute('y1', startY);
            line.setAttribute('x2', endX);
            line.setAttribute('y2', endY);
            line.setAttribute('stroke', '#3b82f6');
            line.setAttribute('stroke-width', '3');
            line.setAttribute('stroke-linecap', 'round');
            line.setAttribute('opacity', '0.8');
            
            // Create arrowhead
            const arrowSize = 8;
            const lineDx = endX - startX;
            const lineDy = endY - startY;
            const lineDistance = Math.sqrt(lineDx * lineDx + lineDy * lineDy);
            const ux = lineDx / lineDistance;
            const uy = lineDy / lineDistance;
            
            const arrowX = endX - ux * arrowSize;
            const arrowY = endY - uy * arrowSize;
            
            const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            const arrowPoints = [
                `${endX},${endY}`,
                `${arrowX - uy * arrowSize/2},${arrowY + ux * arrowSize/2}`,
                `${arrowX + uy * arrowSize/2},${arrowY - ux * arrowSize/2}`
            ].join(' ');
            
            arrow.setAttribute('points', arrowPoints);
            arrow.setAttribute('fill', '#3b82f6');
            arrow.setAttribute('opacity', '0.8');
            
            svg.appendChild(line);
            svg.appendChild(arrow);
            canvas.appendChild(svg);
            
            // Store connection info for updates
            if (!window.templateConnections) {
                window.templateConnections = [];
            }
            
            window.templateConnections.push({
                id: connectionId,
                fromComponent: fromComponent,
                toComponent: toComponent,
                svg: svg,
                line: line,
                arrow: arrow
            });
        }


        function getComponentEdgePoints(centerX, centerY, width, height) {
            // Use actual component dimensions for edge calculation
            const halfWidth = width / 2;
            const halfHeight = height / 2;
            
            return {
                top: { x: centerX, y: centerY - halfHeight },
                right: { x: centerX + halfWidth, y: centerY },
                bottom: { x: centerX, y: centerY + halfHeight },
                left: { x: centerX - halfWidth, y: centerY }
            };
        }

        function findBestConnectionPoints(fromPoints, toPoints, fromCenterX, fromCenterY, toCenterX, toCenterY) {
            const dx = toCenterX - fromCenterX;
            const dy = toCenterY - fromCenterY;
            
            // Determine which edges to connect based on relative positions
            let fromEdge, toEdge;
            
            // Calculate angle to determine best connection direction
            const angle = Math.atan2(dy, dx);
            const angleDegrees = (angle * 180) / Math.PI;
            
            // Determine connection based on angle
            if (angleDegrees >= -45 && angleDegrees <= 45) {
                // Right connection
                fromEdge = fromPoints.right;
                toEdge = toPoints.left;
            } else if (angleDegrees > 45 && angleDegrees <= 135) {
                // Bottom connection
                fromEdge = fromPoints.bottom;
                toEdge = toPoints.top;
            } else if (angleDegrees > 135 || angleDegrees <= -135) {
                // Left connection
                fromEdge = fromPoints.left;
                toEdge = toPoints.right;
            } else {
                // Top connection
                fromEdge = fromPoints.top;
                toEdge = toPoints.bottom;
            }
            
            return {
                from: fromEdge,
                to: toEdge
            };
        }

        function updateTemplateConnections() {
            if (!window.templateConnections) return;
            
            const canvas = document.getElementById('canvas');
            const canvasRect = canvas.getBoundingClientRect();
            const canvasTransform = canvas.style.transform;
            
            // Parse canvas transform
            const transformMatch = canvasTransform.match(/translate\(([^,]+)px,\s*([^)]+)px\)\s*scale\(([^)]+)\)/);
            const canvasOffsetX = transformMatch ? parseFloat(transformMatch[1]) : 0;
            const canvasOffsetY = transformMatch ? parseFloat(transformMatch[2]) : 0;
            const canvasScale = transformMatch ? parseFloat(transformMatch[3]) : 1;
            
            window.templateConnections.forEach(conn => {
                const fromRect = conn.fromComponent.getBoundingClientRect();
                const toRect = conn.toComponent.getBoundingClientRect();
                
                // Calculate positions in untransformed canvas space
                const fromX = (fromRect.left - canvasRect.left - canvasOffsetX) / canvasScale + (fromRect.width / canvasScale) / 2;
                const fromY = (fromRect.top - canvasRect.top - canvasOffsetY) / canvasScale + (fromRect.height / canvasScale) / 2;
                const toX = (toRect.left - canvasRect.left - canvasOffsetX) / canvasScale + (toRect.width / canvasScale) / 2;
                const toY = (toRect.top - canvasRect.top - canvasOffsetY) / canvasScale + (toRect.height / canvasScale) / 2;
                
                const fromWidth = fromRect.width / canvasScale;
                const fromHeight = fromRect.height / canvasScale;
                const toWidth = toRect.width / canvasScale;
                const toHeight = toRect.height / canvasScale;
                
                const deltaX = toX - fromX;
                const deltaY = toY - fromY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                if (distance < 50) {
                    // Hide connection if components are too close
                    conn.svg.style.display = 'none';
                    return;
                } else {
                    conn.svg.style.display = 'block';
                }
                
                // Calculate connection points using proper edge detection
                const fromPoints = getComponentEdgePoints(fromX, fromY, fromWidth, fromHeight);
                const toPoints = getComponentEdgePoints(toX, toY, toWidth, toHeight);
                
                // Find best connection points
                const connection = findBestConnectionPoints(fromPoints, toPoints, fromX, fromY, toX, toY);
                
                const startX = connection.from.x;
                const startY = connection.from.y;
                const endX = connection.to.x;
                const endY = connection.to.y;
                
                // Update line
                conn.line.setAttribute('x1', startX);
                conn.line.setAttribute('y1', startY);
                conn.line.setAttribute('x2', endX);
                conn.line.setAttribute('y2', endY);
                
                // Update arrowhead
                const arrowSize = 8;
                const lineDx = endX - startX;
                const lineDy = endY - startY;
                const lineDistance = Math.sqrt(lineDx * lineDx + lineDy * lineDy);
                const ux = lineDx / lineDistance;
                const uy = lineDy / lineDistance;
                
                const arrowX = endX - ux * arrowSize;
                const arrowY = endY - uy * arrowSize;
                
                const arrowPoints = [
                    `${endX},${endY}`,
                    `${arrowX - uy * arrowSize/2},${arrowY + ux * arrowSize/2}`,
                    `${arrowX + uy * arrowSize/2},${arrowY - ux * arrowSize/2}`
                ].join(' ');
                
                conn.arrow.setAttribute('points', arrowPoints);
            });
        }

        function loadProject(projectId) {
            // In a real application, this would load from localStorage or API
            showNotification(`Loading project: ${projectId}`, 'success');
        }

        function autoSave() {
            const projectData = {
                components: droppedComponents.map(comp => ({
                    type: comp.dataset.type,
                    cost: comp.dataset.cost,
                    id: comp.dataset.id,
                    position: {
                        x: parseInt(comp.style.left),
                        y: parseInt(comp.style.top)
                    }
                })),
                metrics: {
                    totalCost,
                    performanceScore,
                    scalability,
                    securityLevel
                },
                timestamp: new Date().toISOString()
            };
            
            localStorage.setItem('architecture_autosave', JSON.stringify(projectData));
            showAutoSaveIndicator();
        }

        function showAutoSaveIndicator() {
            const indicator = document.getElementById('autoSaveIndicator');
            indicator.style.display = 'block';
            setTimeout(() => {
                indicator.style.display = 'none';
            }, 2000);
        }

        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        function showTutorial() {
            document.getElementById('tutorialOverlay').style.display = 'flex';
            currentTutorialStep = 1;
            updateTutorialStep();
        }

        function hideTutorial() {
            document.getElementById('tutorialOverlay').style.display = 'none';
        }

        function nextTutorialStep() {
            currentTutorialStep++;
            updateTutorialStep();
        }

        function prevTutorialStep() {
            currentTutorialStep--;
            updateTutorialStep();
        }

        function updateTutorialStep() {
            document.querySelectorAll('.tutorial-step').forEach(step => {
                step.classList.remove('active');
            });
            document.getElementById(`step${currentTutorialStep}`).classList.add('active');
        }

        function toggleShortcuts() {
            const shortcuts = document.getElementById('keyboardShortcuts');
            shortcuts.style.display = shortcuts.style.display === 'none' ? 'block' : 'none';
        }

        function hideShortcuts() {
            document.getElementById('keyboardShortcuts').style.display = 'none';
        }

        // Component Information System
        const componentDatabase = {
            'aws-ec2': {
                name: 'AWS EC2',
                icon: 'fab fa-aws',
                description: 'Elastic Compute Cloud - Scalable virtual servers in the cloud',
                cost: 50,
                rating: 4.5,
                tags: ['aws', 'compute', 'scalable'],
                specs: {
                    'CPU': '2 vCPUs',
                    'Memory': '4 GB RAM',
                    'Storage': '20 GB SSD',
                    'Network': 'Up to 10 Gbps'
                },
                useCases: [
                    {
                        title: 'Web Applications',
                        description: 'Host dynamic websites and web applications with auto-scaling capabilities'
                    },
                    {
                        title: 'API Services',
                        description: 'Build RESTful APIs and microservices with high availability'
                    },
                    {
                        title: 'Development Environment',
                        description: 'Create isolated development and testing environments'
                    }
                ],
                pros: [
                    'Pay-as-you-go pricing model',
                    'Auto-scaling capabilities',
                    'Wide range of instance types',
                    'Integrated with AWS ecosystem',
                    'High availability and reliability'
                ],
                cons: [
                    'Can be expensive for small projects',
                    'Requires AWS knowledge',
                    'Cold start delays for some instances',
                    'Complex pricing structure'
                ],
                documentation: 'https://docs.aws.amazon.com/ec2/',
                bestPractices: [
                    'Use appropriate instance types for your workload',
                    'Implement auto-scaling groups for high availability',
                    'Monitor costs and usage regularly',
                    'Use spot instances for non-critical workloads'
                ]
            },
            'aws-rds': {
                name: 'AWS RDS',
                icon: 'fas fa-database',
                description: 'Relational Database Service - Managed database hosting',
                cost: 80,
                rating: 4.7,
                tags: ['aws', 'database', 'managed'],
                specs: {
                    'Engine': 'MySQL/PostgreSQL',
                    'Storage': '100 GB SSD',
                    'Backup': 'Automated daily',
                    'Multi-AZ': 'Available'
                },
                useCases: [
                    {
                        title: 'Transactional Data',
                        description: 'Store and manage transactional data for e-commerce and business applications'
                    },
                    {
                        title: 'User Management',
                        description: 'Handle user authentication, profiles, and permissions'
                    },
                    {
                        title: 'Analytics & Reporting',
                        description: 'Support complex queries and data analysis'
                    }
                ],
                pros: [
                    'Fully managed service',
                    'Automated backups and patching',
                    'High availability with Multi-AZ',
                    'Easy scaling',
                    'Security features built-in'
                ],
                cons: [
                    'Limited customization options',
                    'Higher cost than self-managed',
                    'Vendor lock-in',
                    'Limited to supported database engines'
                ],
                documentation: 'https://docs.aws.amazon.com/rds/',
                bestPractices: [
                    'Enable Multi-AZ for production workloads',
                    'Set up automated backups',
                    'Monitor performance metrics',
                    'Use read replicas for read-heavy workloads'
                ]
            },
            'aws-lambda': {
                name: 'AWS Lambda',
                icon: 'fas fa-bolt',
                description: 'Serverless compute service - Run code without managing servers',
                cost: 20,
                rating: 4.6,
                tags: ['aws', 'serverless', 'event-driven'],
                specs: {
                    'Runtime': 'Node.js, Python, Java',
                    'Memory': 'Up to 10 GB',
                    'Timeout': '15 minutes max',
                    'Concurrency': '1000 concurrent executions'
                },
                useCases: [
                    {
                        title: 'Event Processing',
                        description: 'Process events from S3, DynamoDB, or API Gateway'
                    },
                    {
                        title: 'API Backend',
                        description: 'Build serverless APIs with automatic scaling'
                    },
                    {
                        title: 'Data Transformation',
                        description: 'Transform and process data in real-time'
                    }
                ],
                pros: [
                    'No server management',
                    'Pay per execution',
                    'Automatic scaling',
                    'Event-driven architecture',
                    'Cost-effective for sporadic workloads'
                ],
                cons: [
                    'Cold start latency',
                    '15-minute execution limit',
                    'Limited control over runtime',
                    'Can be expensive for high-frequency workloads'
                ],
                documentation: 'https://docs.aws.amazon.com/lambda/',
                bestPractices: [
                    'Keep functions small and focused',
                    'Use provisioned concurrency for critical functions',
                    'Optimize cold start performance',
                    'Monitor and set up alerts'
                ]
            },
            'azure-vm': {
                name: 'Azure VM',
                icon: 'fab fa-microsoft',
                description: 'Azure Virtual Machines - Scalable cloud computing',
                cost: 45,
                rating: 4.4,
                tags: ['azure', 'compute', 'enterprise'],
                specs: {
                    'CPU': '2 vCPUs',
                    'Memory': '8 GB RAM',
                    'Storage': '30 GB SSD',
                    'Network': 'Up to 1 Gbps'
                },
                useCases: [
                    {
                        title: 'Enterprise Applications',
                        description: 'Run enterprise applications with hybrid cloud capabilities'
                    },
                    {
                        title: 'Development & Testing',
                        description: 'Create development and testing environments'
                    },
                    {
                        title: 'Windows Workloads',
                        description: 'Host Windows-based applications and services'
                    }
                ],
                pros: [
                    'Hybrid cloud capabilities',
                    'Windows and Linux support',
                    'Enterprise-grade security',
                    'Integration with Microsoft ecosystem',
                    'Flexible pricing options'
                ],
                cons: [
                    'Steeper learning curve',
                    'Less mature than AWS',
                    'Complex pricing model',
                    'Limited third-party integrations'
                ],
                documentation: 'https://docs.microsoft.com/en-us/azure/virtual-machines/',
                bestPractices: [
                    'Use Azure Resource Manager templates',
                    'Implement proper security groups',
                    'Monitor costs and usage',
                    'Use availability sets for high availability'
                ]
            },
            'load-balancer': {
                name: 'Load Balancer',
                icon: 'fas fa-balance-scale',
                description: 'Distributes incoming traffic across multiple servers for high availability',
                cost: 30,
                rating: 4.6,
                tags: ['performance', 'scalability', 'availability'],
                specs: {
                    'Type': 'Application Load Balancer',
                    'Protocols': 'HTTP/HTTPS',
                    'Health Checks': 'Automatic',
                    'SSL Termination': 'Supported'
                },
                useCases: [
                    {
                        title: 'High Availability',
                        description: 'Ensure application availability by distributing traffic across multiple servers'
                    },
                    {
                        title: 'Traffic Management',
                        description: 'Route traffic based on rules, content, or geographic location'
                    },
                    {
                        title: 'Auto Scaling',
                        description: 'Automatically scale resources based on traffic demand'
                    }
                ],
                pros: [
                    'High availability and fault tolerance',
                    'Automatic health checking',
                    'SSL termination support',
                    'Easy configuration and management',
                    'Cost-effective scaling solution'
                ],
                cons: [
                    'Single point of failure if not configured properly',
                    'Additional latency overhead',
                    'Requires proper backend configuration',
                    'Can be complex to troubleshoot'
                ],
                documentation: 'https://docs.aws.amazon.com/elasticloadbalancing/',
                bestPractices: [
                    'Configure health checks properly',
                    'Use multiple availability zones',
                    'Monitor load balancer metrics',
                    'Implement proper security groups'
                ]
            },
            'api-gateway': {
                name: 'API Gateway',
                icon: 'fas fa-door-open',
                description: 'Centralized entry point for API management and security',
                cost: 25,
                rating: 4.5,
                tags: ['api', 'security', 'management'],
                specs: {
                    'Protocols': 'REST, WebSocket',
                    'Rate Limiting': 'Configurable',
                    'Authentication': 'Multiple methods',
                    'Monitoring': 'Built-in analytics'
                },
                useCases: [
                    {
                        title: 'API Security',
                        description: 'Centralize authentication, authorization, and rate limiting'
                    },
                    {
                        title: 'API Management',
                        description: 'Monitor, log, and manage API usage and performance'
                    },
                    {
                        title: 'Microservices Gateway',
                        description: 'Route requests to appropriate microservices'
                    }
                ],
                pros: [
                    'Centralized API management',
                    'Built-in security features',
                    'Rate limiting and throttling',
                    'API versioning support',
                    'Comprehensive monitoring'
                ],
                cons: [
                    'Additional latency overhead',
                    'Vendor lock-in concerns',
                    'Limited customization options',
                    'Can become a bottleneck'
                ],
                documentation: 'https://docs.aws.amazon.com/apigateway/',
                bestPractices: [
                    'Implement proper rate limiting',
                    'Use API versioning strategies',
                    'Monitor API performance metrics',
                    'Implement proper caching'
                ]
            },
            'redis-cache': {
                name: 'Redis Cache',
                icon: 'fas fa-memory',
                description: 'High-performance in-memory data store for caching and real-time applications',
                cost: 40,
                rating: 4.7,
                tags: ['cache', 'performance', 'memory'],
                specs: {
                    'Memory': '2 GB RAM',
                    'Persistence': 'RDB + AOF',
                    'Clustering': 'Supported',
                    'Data Types': 'Strings, Lists, Sets, Hashes'
                },
                useCases: [
                    {
                        title: 'Application Caching',
                        description: 'Cache frequently accessed data to improve application performance'
                    },
                    {
                        title: 'Session Storage',
                        description: 'Store user sessions for web applications'
                    },
                    {
                        title: 'Real-time Data',
                        description: 'Power real-time features like live chat and notifications'
                    }
                ],
                pros: [
                    'Extremely fast performance',
                    'Rich data structures',
                    'Persistence options',
                    'Pub/Sub messaging',
                    'Easy to scale'
                ],
                cons: [
                    'Memory intensive',
                    'Data loss risk if not configured properly',
                    'Limited query capabilities',
                    'Requires careful memory management'
                ],
                documentation: 'https://redis.io/documentation',
                bestPractices: [
                    'Configure appropriate memory limits',
                    'Use persistence for critical data',
                    'Monitor memory usage',
                    'Implement proper eviction policies'
                ]
            },
            'mongodb': {
                name: 'MongoDB',
                icon: 'fas fa-leaf',
                description: 'Document-oriented NoSQL database for flexible data storage',
                cost: 60,
                rating: 4.3,
                tags: ['database', 'nosql', 'document'],
                specs: {
                    'Storage': '100 GB',
                    'Replication': '3-node replica set',
                    'Indexing': 'Multiple index types',
                    'Sharding': 'Supported'
                },
                useCases: [
                    {
                        title: 'Content Management',
                        description: 'Store and manage dynamic content for websites and applications'
                    },
                    {
                        title: 'User Profiles',
                        description: 'Store flexible user data and preferences'
                    },
                    {
                        title: 'Analytics & Reporting',
                        description: 'Aggregate and analyze large datasets'
                    }
                ],
                pros: [
                    'Flexible schema design',
                    'Horizontal scaling',
                    'Rich query language',
                    'Good performance for read-heavy workloads',
                    'Easy to get started'
                ],
                cons: [
                    'Memory usage can be high',
                    'Complex queries can be slow',
                    'Limited ACID guarantees',
                    'Requires careful indexing'
                ],
                documentation: 'https://docs.mongodb.com/',
                bestPractices: [
                    'Design proper indexes',
                    'Use appropriate data types',
                    'Monitor query performance',
                    'Implement proper backup strategies'
                ]
            },
            'kafka': {
                name: 'Apache Kafka',
                icon: 'fas fa-stream',
                description: 'Distributed streaming platform for real-time data processing',
                cost: 70,
                rating: 4.4,
                tags: ['streaming', 'messaging', 'real-time'],
                specs: {
                    'Throughput': 'Millions of messages/sec',
                    'Partitions': 'Configurable',
                    'Replication': '3x replication',
                    'Retention': 'Configurable'
                },
                useCases: [
                    {
                        title: 'Event Streaming',
                        description: 'Process real-time events and data streams'
                    },
                    {
                        title: 'Microservices Communication',
                        description: 'Enable asynchronous communication between services'
                    },
                    {
                        title: 'Data Pipeline',
                        description: 'Build real-time data processing pipelines'
                    }
                ],
                pros: [
                    'High throughput and low latency',
                    'Fault tolerance and durability',
                    'Horizontal scaling',
                    'Rich ecosystem',
                    'Real-time processing'
                ],
                cons: [
                    'Complex to set up and manage',
                    'Steep learning curve',
                    'Requires careful tuning',
                    'Not suitable for simple use cases'
                ],
                documentation: 'https://kafka.apache.org/documentation/',
                bestPractices: [
                    'Design proper topic partitioning',
                    'Configure appropriate retention policies',
                    'Monitor consumer lag',
                    'Use proper serialization formats'
                ]
            },
            'waf': {
                name: 'Web Application Firewall',
                icon: 'fas fa-shield-alt',
                description: 'Protects web applications from common attacks and threats',
                cost: 35,
                rating: 4.5,
                tags: ['security', 'protection', 'firewall'],
                specs: {
                    'Rules': 'Pre-configured + custom',
                    'DDoS Protection': 'Included',
                    'Bot Protection': 'Advanced',
                    'SSL/TLS': 'Termination support'
                },
                useCases: [
                    {
                        title: 'Security Protection',
                        description: 'Block common web attacks like SQL injection and XSS'
                    },
                    {
                        title: 'DDoS Mitigation',
                        description: 'Protect against distributed denial of service attacks'
                    },
                    {
                        title: 'Bot Management',
                        description: 'Filter and manage bot traffic'
                    }
                ],
                pros: [
                    'Comprehensive security rules',
                    'DDoS protection included',
                    'Easy to configure',
                    'Real-time monitoring',
                    'Cost-effective security'
                ],
                cons: [
                    'Can block legitimate traffic if misconfigured',
                    'Additional latency overhead',
                    'Requires regular rule updates',
                    'May need fine-tuning'
                ],
                documentation: 'https://docs.aws.amazon.com/waf/',
                bestPractices: [
                    'Start with pre-configured rules',
                    'Monitor and tune rules regularly',
                    'Test rules in monitoring mode first',
                    'Keep rules updated'
                ]
            },
            'cdn': {
                name: 'Content Delivery Network',
                icon: 'fas fa-globe',
                description: 'Distributes content globally for faster access and better performance',
                cost: 15,
                rating: 4.6,
                tags: ['performance', 'global', 'content'],
                specs: {
                    'Edge Locations': '200+ worldwide',
                    'Cache TTL': 'Configurable',
                    'Compression': 'Gzip/Brotli',
                    'HTTPS': 'Full support'
                },
                useCases: [
                    {
                        title: 'Static Content Delivery',
                        description: 'Serve images, CSS, JavaScript, and other static assets'
                    },
                    {
                        title: 'Media Streaming',
                        description: 'Deliver video and audio content globally'
                    },
                    {
                        title: 'Website Acceleration',
                        description: 'Improve website loading times worldwide'
                    }
                ],
                pros: [
                    'Global content distribution',
                    'Significant performance improvement',
                    'Reduced origin server load',
                    'Cost-effective scaling',
                    'Easy to implement'
                ],
                cons: [
                    'Cache invalidation complexity',
                    'Additional cost for high traffic',
                    'Limited dynamic content support',
                    'Potential cache inconsistency'
                ],
                documentation: 'https://docs.aws.amazon.com/cloudfront/',
                bestPractices: [
                    'Configure appropriate cache headers',
                    'Use cache invalidation wisely',
                    'Monitor cache hit ratios',
                    'Implement proper error handling'
                ]
            }
        };

        function showComponentInfo(componentType) {
            const component = componentDatabase[componentType];
            if (!component) return;

            const modal = document.getElementById('componentInfoModal');
            const title = document.getElementById('modalTitle');
            const subtitle = document.getElementById('modalSubtitle');
            const body = document.getElementById('modalBody');

            title.innerHTML = `<i class="${component.icon}"></i> ${component.name}`;
            subtitle.textContent = component.description;

            body.innerHTML = `
                <div class="info-section">
                    <div class="component-rating">
                        <div class="stars">${''.repeat(Math.floor(component.rating))}${''.repeat(5 - Math.floor(component.rating))}</div>
                        <span class="rating-text">${component.rating}/5.0 rating</span>
                    </div>
                    <div class="component-tags">
                        ${component.tags.map(tag => `<span class="tag ${tag}">${tag.toUpperCase()}</span>`).join('')}
                    </div>
                </div>

                <div class="info-section">
                    <h3><i class="fas fa-cogs"></i> Specifications</h3>
                    <div class="info-grid">
                        ${Object.entries(component.specs).map(([key, value]) => `
                            <div class="info-card">
                                <div class="info-card-title">${key}</div>
                                <div class="info-card-value">${value}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>

                <div class="info-section">  
                    <h3><i class="fas fa-lightbulb"></i> Use Cases</h3>
                    <div class="use-cases">
                        ${component.useCases.map(useCase => `
                            <div class="use-case">
                                <div class="use-case-title">${useCase.title}</div>
                                <div class="use-case-desc">${useCase.description}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>

                <div class="info-section">
                    <h3><i class="fas fa-balance-scale"></i> Pros & Cons</h3>
                    <div class="pros-cons">
                        <div class="pros">
                            <h4><i class="fas fa-check-circle"></i> Advantages</h4>
                            <ul>
                                ${component.pros.map(pro => `<li>${pro}</li>`).join('')}
                            </ul>
                        </div>
                        <div class="cons">
                            <h4><i class="fas fa-times-circle"></i> Limitations</h4>
                            <ul>
                                ${component.cons.map(con => `<li>${con}</li>`).join('')}
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="info-section">
                    <h3><i class="fas fa-graduation-cap"></i> Best Practices</h3>
                    <ul style="list-style: none; padding: 0;">
                        ${component.bestPractices.map(practice => `
                            <li style="padding: 0.5rem 0; border-left: 3px solid #3498db; padding-left: 1rem; margin-bottom: 0.5rem; background: #f8f9fa; border-radius: 0 8px 8px 0;">
                                <i class="fas fa-arrow-right" style="color: #3498db; margin-right: 0.5rem;"></i>
                                ${practice}
                            </li>
                        `).join('')}
                    </ul>
                </div>

                <div class="info-section">
                    <h3><i class="fas fa-dollar-sign"></i> Cost Information</h3>
                    <div class="info-grid">
                        <div class="info-card">
                            <div class="info-card-title">Monthly Cost</div>
                            <div class="info-card-value">$${component.cost}/month</div>
                        </div>
                        <div class="info-card">
                            <div class="info-card-title">Pricing Model</div>
                            <div class="info-card-value">Pay-as-you-go</div>
                        </div>
                    </div>
                </div>

                <button class="learn-more-btn" onclick="window.open('${component.documentation}', '_blank')">
                    <i class="fas fa-external-link-alt"></i>
                    View Official Documentation
                </button>
            `;

            modal.style.display = 'flex';
        }

        function hideComponentInfo() {
            document.getElementById('componentInfoModal').style.display = 'none';
        }

        // Close modal when clicking outside
        document.getElementById('componentInfoModal').addEventListener('click', function(e) {
            if (e.target === this) {
                hideComponentInfo();
            }
        });

        // Sidebar toggle functionality
        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const workspace = document.querySelector('.workspace');
            const canvas = document.querySelector('.canvas');
            const toggleBtn = document.getElementById('sidebarToggleBtn');
            const toggleText = document.getElementById('sidebarToggleText');
            const toggleIcon = toggleBtn.querySelector('i');

            if (sidebar.classList.contains('collapsed')) {
                // Show sidebar
                sidebar.classList.remove('collapsed');
                workspace.classList.remove('sidebar-collapsed');
                canvas.classList.remove('sidebar-collapsed');
                toggleText.textContent = 'Hide';
                toggleIcon.className = 'fas fa-bars';
            } else {
                // Hide sidebar
                sidebar.classList.add('collapsed');
                workspace.classList.add('sidebar-collapsed');
                canvas.classList.add('sidebar-collapsed');
                toggleText.textContent = 'Show';
                toggleIcon.className = 'fas fa-bars';
            }
        }
    </script>
</body>
</html>
