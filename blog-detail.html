<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blog Detail - Rahadi Sampurna</title>
    <link rel="canonical" href="https://rahadisampurno.github.io/porto/blog-detail.html" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="Rahadi Sampurna - Blog" />
    <meta property="og:description" content="Technical articles and guides by Rahadi Sampurna." />
    <meta property="og:url" content="https://rahadisampurno.github.io/porto/blog-detail.html" />
    <meta property="og:image" content="https://images.unsplash.com/photo-1519389950473-47ba0277781c?auto=format&fit=crop&w=1200&q=80" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Rahadi Sampurna - Blog" />
    <meta name="twitter:description" content="Technical articles and guides by Rahadi Sampurna." />
    <meta name="twitter:image" content="https://images.unsplash.com/photo-1519389950473-47ba0277781c?auto=format&fit=crop&w=1200&q=80" />
    <script id="ld-json" type="application/ld+json"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body { font-family: 'Inter', sans-serif; }
        code, .font-mono { font-family: 'Fira Code', monospace; }
        .gradient-bg { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .backdrop-blur { backdrop-filter: blur(10px); }
        .prose { max-width: none; }
        .prose h1, .prose h2, .prose h3, .prose h4 { color: #1f2937; font-weight: 600; }
        .prose p { color: #4b5563; line-height: 1.7; }
        .prose code { background-color: #f3f4f6; padding: 0.25rem 0.5rem; border-radius: 0.375rem; font-size: 0.875rem; }
        .prose pre { background-color: #1f2937; color: #f9fafb; padding: 1rem; border-radius: 0.5rem; overflow-x: auto; }
        .prose pre code { background-color: transparent; padding: 0; }
    </style>
</head>
<body class="bg-gray-50">
    <!-- Navigation -->
    <nav class="fixed w-full top-0 z-50 bg-white/90 backdrop-blur border-b border-gray-200">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between items-center h-16">
                <div class="flex items-center">
                    <a href="index.html" class="text-2xl font-bold text-gray-900">
                        <span class="text-blue-600">Rahadi</span>Sampurna
                    </a>
                </div>
                <div class="flex items-center space-x-4">
                    <a href="index.html" class="text-gray-600 hover:text-blue-600 px-3 py-2 text-sm font-medium transition-colors">← Back to Blog</a>
                    <a href="CV ATS RAHADI.pdf" target="_blank" class="bg-blue-600 text-white px-4 py-2 rounded-lg text-sm font-medium hover:bg-blue-700 transition-colors">View CV</a>
                </div>
            </div>
        </div>
    </nav>

    <!-- Blog Content -->
    <div class="pt-16">
        <div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
            <!-- Blog Header -->
            <div id="blog-header" class="mb-12">
                <!-- Content will be populated by JavaScript -->
            </div>

            <!-- Blog Content -->
            <div class="grid lg:grid-cols-4 gap-12">
                <!-- Main Content -->
                <div class="lg:col-span-3">
                    <article class="bg-white rounded-xl shadow-lg p-8">
                        <div id="blog-content" class="prose">
                            <!-- Content will be populated by JavaScript -->
                        </div>
                    </article>
                </div>

                <!-- Sidebar -->
                <div class="space-y-8">
                    <!-- Author Info -->
                    <div class="bg-white rounded-xl shadow-lg p-6">
                        <h3 class="text-lg font-semibold text-gray-900 mb-4">About the Author</h3>
                        <div class="flex items-center mb-4">
                            <div class="w-12 h-12 bg-blue-600 rounded-full flex items-center justify-center text-white font-bold text-lg">
                                RS
                            </div>
                            <div class="ml-3">
                                <h4 class="font-semibold text-gray-900">Rahadi Sampurna</h4>
                                <p class="text-sm text-gray-600">Backend Engineer</p>
                            </div>
                        </div>
                        <p class="text-sm text-gray-600">
                            Backend Engineer with 10+ years of experience in system integration, microservices architecture, and API development. 
                            Passionate about sharing knowledge and best practices in backend development.
                        </p>
                    </div>

                    <!-- Related Posts -->
                    <div class="bg-white rounded-xl shadow-lg p-6">
                        <h3 class="text-lg font-semibold text-gray-900 mb-4">Related Posts</h3>
                        <div class="space-y-3">
                            <a href="blog-detail.html?post=mongodb-optimization" class="block p-3 rounded-lg border border-gray-200 hover:border-blue-300 hover:bg-blue-50 transition-colors">
                                <div class="font-medium text-gray-900">MongoDB Performance Optimization</div>
                                <div class="text-sm text-gray-600">December 10, 2024</div>
                            </a>
                            <a href="blog-detail.html?post=ai-backend" class="block p-3 rounded-lg border border-gray-200 hover:border-blue-300 hover:bg-blue-50 transition-colors">
                                <div class="font-medium text-gray-900">Integrating AI into Backend Services</div>
                                <div class="text-sm text-gray-600">December 5, 2024</div>
                            </a>
                            <a href="blog-detail.html?post=kafka-simulator" class="block p-3 rounded-lg border border-gray-200 hover:border-blue-300 hover:bg-blue-50 transition-colors">
                                <div class="font-medium text-gray-900">Kafka Simulator</div>
                                <div class="text-sm text-gray-600">December 20, 2024</div>
                            </a>
                        </div>
                    </div>

                    <!-- Tags -->
                    <div class="bg-white rounded-xl shadow-lg p-6">
                        <h3 class="text-lg font-semibold text-gray-900 mb-4">Tags</h3>
                        <div id="blog-tags" class="flex flex-wrap gap-2">
                            <!-- Content will be populated by JavaScript -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <footer class="bg-gray-900 text-white py-12">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="text-center">
                <h3 class="text-2xl font-bold mb-4">
                    <span class="text-blue-400">Rahadi</span>Sampurna
                </h3>
                <p class="text-gray-400 mb-6">Backend Engineer with 10+ years of experience building scalable systems</p>
                <div class="flex justify-center space-x-6">
                    <a href="index.html" class="text-gray-400 hover:text-white transition-colors">Portfolio</a>
                    <a href="index.html#blog" class="text-gray-400 hover:text-white transition-colors">Blog</a>
                    <a href="rahadi-cv.html" class="text-gray-400 hover:text-white transition-colors">Resume</a>
                    <a href="index.html#contact" class="text-gray-400 hover:text-white transition-colors">Contact</a>
                </div>
            </div>
        </div>
    </footer>

    <script>
        // Blog posts data
        const blogPosts = {
            'golang-microservices': {
                title: 'Building Scalable Microservices with Golang',
                date: 'December 12, 2024',
                readTime: '8 min read',
                icon: 'fas fa-microservices',
                gradient: 'from-blue-500 to-indigo-600',
                tags: ['Golang', 'Microservices', 'Architecture', 'Backend'],
                cover: 'https://images.unsplash.com/photo-1518186285589-2f7649de83e0?auto=format&fit=crop&w=1200&q=80',
                content: `
                    <h1>Membangun Microservices yang Scalable dengan Golang</h1>
                    
                    <p>Di era digital yang serba cepat kayak sekarang, bikin sistem backend yang scalable dan maintainable itu krusial banget buat kesuksesan bisnis. Golang, dengan model concurrency yang excellent dan karakteristik performa yang bagus, udah jadi pilihan populer buat bikin arsitektur microservices.</p>

                    <h2>Kenapa Pilih Golang buat Microservices?</h2>
                    
                    <p>Golang nyediain beberapa keuntungan yang bikin dia ideal buat development microservices:</p>
                    
                    <ul>
                        <li><strong>Concurrency:</strong> Goroutines nyediain lightweight concurrency yang bikin gampang handle ribuan concurrent request</li>
                        <li><strong>Performance:</strong> Compiled language dengan performa yang nyaris setara C-level</li>
                        <li><strong>Simplicity:</strong> Syntax yang bersih dan learning curve yang minimal</li>
                        <li><strong>Built-in Tools:</strong> Tooling yang excellent buat testing, profiling, dan deployment</li>
                        <li><strong>Cross-platform:</strong> Single binary deployment di berbagai platform</li>
                    </ul>

                    <h2>Design Arsitektur Microservices</h2>
                    
                    <p>Pas design microservices dengan Golang, pertimbangkan prinsip-prinsip kunci ini:</p>

                    <h3>1. Service Boundaries</h3>
                    <p>Definisikan batas service yang jelas berdasarkan business capabilities, bukan technical layers. Setiap service harus punya single responsibility dan bisa di-deploy secara independen.</p>

                    <h3>2. Pola Komunikasi</h3>
                    <p>Pilih pola komunikasi yang sesuai:</p>
                    <ul>
                        <li><strong>Synchronous:</strong> HTTP/REST buat pola request-response</li>
                        <li><strong>Asynchronous:</strong> Message queues buat komunikasi event-driven</li>
                        <li><strong>gRPC:</strong> Buat komunikasi internal yang high-performance</li>
                    </ul>

                    <h3>3. Manajemen Data</h3>
                    <p>Setiap microservice harus punya data sendiri. Hindari shared databases dan implementasi eventual consistency kalo diperlukan.</p>

                    <h2>Contoh Implementasi</h2>
                    
                    <p>Mari kita liat implementasi microservice yang sederhana:</p>

                    <pre><code>package main

import (
    "encoding/json"
    "log"
    "net/http"
    "time"
    
    "github.com/gorilla/mux"
)

type UserService struct {
    users map[string]User
}

type User struct {
    ID    string \`json:"id"\`
    Name  string \`json:"name"\`
    Email string \`json:"email"\`
}

func (s *UserService) GetUser(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    userID := vars["id"]
    
    user, exists := s.users[userID]
    if !exists {
        http.NotFound(w, r)
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(user)
}

func main() {
    r := mux.NewRouter()
    userService := &UserService{
        users: make(map[string]User),
    }
    
    r.HandleFunc("/users/{id}", userService.GetUser).Methods("GET")
    
    srv := &http.Server{
        Handler:      r,
        Addr:         ":8080",
        WriteTimeout: 15 * time.Second,
        ReadTimeout:  15 * time.Second,
    }
    
    log.Fatal(srv.ListenAndServe())
}</code></pre>

                    <h2>Best Practices</h2>
                    
                    <h3>1. Error Handling</h3>
                    <p>Implementasi error handling yang konsisten di semua service. Pake custom error types dan HTTP status codes yang tepat.</p>

                    <h3>2. Logging dan Monitoring</h3>
                    <p>Implementasi structured logging dan distributed tracing buat monitor kesehatan dan performa service.</p>

                    <h3>3. Manajemen Konfigurasi</h3>
                    <p>Pake environment variables atau configuration files buat konfigurasi service. Pertimbangkan pake tools kayak Consul atau etcd buat dynamic configuration.</p>

                    <h3>4. Testing</h3>
                    <p>Tulis test yang komprehensif termasuk unit tests, integration tests, dan contract tests antar service.</p>

                    <h2>Deployment dan Scaling</h2>
                    
                    <p>Containerize service kamu pake Docker dan deploy di Kubernetes buat scaling dan management yang mudah. Pake service mesh kayak Istio buat advanced traffic management dan security.</p>

                    <h2>Kesimpulan</h2>
                    
                    <p>Bikin microservices dengan Golang butuh perencanaan yang hati-hati dan adherence ke best practices. Dengan ngikutin prinsip yang udah dijelasin di artikel ini, kamu bisa bikin arsitektur microservices yang scalable, maintainable, dan performant yang bisa berkembang sesuai kebutuhan bisnis kamu.</p>

                    <p>Ingat buat mulai dari yang sederhana dulu dan tambah kompleksitas secara bertahap pas sistem kamu berkembang. Fokus ke observability, testing, dan dokumentasi dari awal buat pastikan kesuksesan jangka panjang.</p>
                `
            },
            'mongodb-optimization': {
                title: 'MongoDB Performance Optimization Techniques',
                date: 'December 10, 2024',
                readTime: '12 min read',
                icon: 'fas fa-database',
                gradient: 'from-green-500 to-emerald-600',
                tags: ['MongoDB', 'Performance', 'Database', 'Optimization'],
                cover: 'https://images.unsplash.com/photo-1551288049-bebda4e38f71?auto=format&fit=crop&w=1200&q=80',
                content: `
                    <h1>Teknik Optimasi Performa MongoDB</h1>
                    
                    <p>MongoDB itu database NoSQL yang powerful banget buat handle data dalam jumlah besar dan aplikasi dengan traffic tinggi. Tapi, kalo ga dioptimasi dengan bener, performa bisa turun drastis pas data kamu makin banyak. Di panduan lengkap ini, kita bakal explore berbagai teknik buat optimasi performa MongoDB.</p>

                    <h2>Memahami Performa MongoDB</h2>
                    
                    <p>Sebelum masuk ke teknik optimasi, penting banget buat ngerti gimana MongoDB kerja secara internal dan faktor-faktor apa aja yang ngaruh ke performa:</p>

                    <ul>
                        <li><strong>Indexing:</strong> Index yang tepat itu krusial banget buat performa query</li>
                        <li><strong>Memory Usage:</strong> MongoDB pake memory buat cache data yang sering diakses</li>
                        <li><strong>Disk I/O:</strong> Minimize operasi disk bisa nambah performa</li>
                        <li><strong>Query Patterns:</strong> Cara kamu struktur query ngaruh ke performa</li>
                        <li><strong>Data Modeling:</strong> Struktur dokumen ngaruh ke efisiensi query</li>
                    </ul>

                    <h2>Strategi Indexing</h2>
                    
                    <h3>1. Single Field Indexes</h3>
                    <p>Bikin index di field yang sering di-query:</p>
                    
                    <pre><code>// Bikin index di field email
db.users.createIndex({ "email": 1 })

// Bikin compound index
db.users.createIndex({ "email": 1, "status": 1 })</code></pre>

                    <h3>2. Compound Indexes</h3>
                    <p>Buat query yang filter di multiple field, bikin compound index. Ikutin aturan ESR (Equality, Sort, Range):</p>

                    <pre><code>// Compound index yang bagus buat query ini
db.orders.find({ "status": "active", "createdAt": { $gte: ISODate("2024-01-01") } })
         .sort({ "createdAt": -1 })

// Bikin index ikutin aturan ESR
db.orders.createIndex({ "status": 1, "createdAt": -1 })</code></pre>

                    <h3>3. Text Indexes</h3>
                    <p>Buat kemampuan full-text search:</p>

                    <pre><code>// Bikin text index
db.articles.createIndex({ "title": "text", "content": "text" })

// Query pake text search
db.articles.find({ $text: { $search: "mongodb performance" } })</code></pre>

                    <h2>Optimasi Query</h2>
                    
                    <h3>1. Pake Projection</h3>
                    <p>Ambil cuma field yang kamu butuh:</p>

                    <pre><code>// Daripada ambil semua field
db.users.find({ "status": "active" })

// Pake projection buat ambil cuma field yang dibutuhin
db.users.find({ "status": "active" }, { "name": 1, "email": 1, "_id": 0 })</code></pre>

                    <h3>2. Limit Hasil</h3>
                    <p>Pake limit() buat batasin jumlah dokumen yang dikembaliin:</p>

                    <pre><code>db.users.find({ "status": "active" }).limit(10)</code></pre>

                    <h3>3. Pake Explain Plan</h3>
                    <p>Analisis performa query pake explain():</p>

                    <pre><code>db.users.find({ "email": "user@example.com" }).explain("executionStats")</code></pre>

                    <h2>Best Practices Data Modeling</h2>
                    
                    <h3>1. Embed vs Reference</h3>
                    <p>Pilih antara embedding dan referencing berdasarkan use case kamu:</p>

                    <ul>
                        <li><strong>Embed:</strong> Buat data kecil yang sering diakses</li>
                        <li><strong>Reference:</strong> Buat data besar yang jarang diakses</li>
                    </ul>

                    <h3>2. Denormalization</h3>
                    <p>Kadang denormalisasi data bisa nambah performa read:</p>

                    <pre><code>// Dokumen user yang denormalized dengan embedded address
{
  "_id": ObjectId("..."),
  "name": "John Doe",
  "email": "john@example.com",
  "address": {
    "street": "123 Main St",
    "city": "New York",
    "state": "NY",
    "zip": "10001"
  }
}</code></pre>

                    <h2>Strategi Sharding</h2>
                    
                    <p>Buat dataset besar, implementasi sharding buat distribusi data ke multiple server:</p>

                    <h3>1. Pemilihan Shard Key</h3>
                    <p>Pilih shard key yang kasih distribusi bagus dan support query pattern kamu:</p>

                    <pre><code>// Shard berdasarkan user ID buat data user
sh.shardCollection("myapp.users", { "userId": "hashed" })

// Shard berdasarkan date buat time-series data
sh.shardCollection("myapp.events", { "timestamp": 1 })</code></pre>

                    <h2>Monitoring dan Profiling</h2>
                    
                    <h3>1. Enable Profiling</h3>
                    <p>Enable database profiling buat identifikasi operasi yang lambat:</p>

                    <pre><code>// Enable profiling buat operasi yang lebih lambat dari 100ms
db.setProfilingLevel(1, { slowms: 100 })

// Lihat data profiling
db.system.profile.find().sort({ ts: -1 }).limit(5)</code></pre>

                    <h3>2. Monitor Performa</h3>
                    <p>Pake tools monitoring built-in MongoDB:</p>

                    <pre><code>// Cek status server
db.serverStatus()

// Cek stats database
db.stats()

// Cek stats collection
db.users.stats()</code></pre>

                    <h2>Optimasi Memory dan Storage</h2>
                    
                    <h3>1. Working Set Size</h3>
                    <p>Pastikan working set mu muat di memory. Monitor working set size:</p>

                    <pre><code>db.runCommand({ "serverStatus": 1 }).wiredTiger.cache["bytes currently in the cache"]</code></pre>

                    <h3>2. Compression</h3>
                    <p>Enable compression buat kurangi kebutuhan storage:</p>

                    <pre><code>// Enable snappy compression
db.createCollection("mycollection", {
  storageEngine: {
    wiredTiger: {
      configString: "block_compressor=snappy"
    }
  }
})</code></pre>

                    <h2>Connection Pooling</h2>
                    
                    <p>Implementasi connection pooling buat manage koneksi database dengan efisien:</p>

                    <pre><code>// Contoh dengan Go driver
client, err := mongo.Connect(ctx, options.Client().ApplyURI("mongodb://localhost:27017"))
if err != nil {
    log.Fatal(err)
}

// Set opsi connection pool
clientOptions := options.Client().ApplyURI("mongodb://localhost:27017")
clientOptions.SetMaxPoolSize(100)
clientOptions.SetMinPoolSize(10)</code></pre>

                    <h2>Kesimpulan</h2>
                    
                    <p>Optimasi performa MongoDB itu proses yang berkelanjutan yang butuh monitoring, testing, dan perbaikan terus-menerus. Dengan implementasi teknik yang udah dibahas di artikel ini, kamu bisa nambah performa MongoDB secara signifikan dan pastikan aplikasi kamu bisa scale dengan efektif.</p>

                    <p>Ingat buat selalu measure sebelum dan sesudah implementasi optimasi, dan pertimbangkan trade-off antara performa read dan write pas bikin keputusan design.</p>
                `
            },
            'ai-backend': {
                title: 'Integrating AI into Backend Services',
                date: 'December 5, 2024',
                readTime: '15 min read',
                icon: 'fas fa-robot',
                gradient: 'from-purple-500 to-pink-600',
                tags: ['AI', 'RAG', 'Backend', 'Machine Learning'],
                cover: 'https://images.unsplash.com/photo-1677442136019-21780ecad995?auto=format&fit=crop&w=1200&q=80',
                content: `
                    <h1>Mengintegrasikan AI ke Layanan Backend</h1>
                    
                    <p>Integrasi Artificial Intelligence (AI) ke layanan backend lagi bikin revolusi besar dalam cara kita bikin dan deploy aplikasi. Mulai dari otomatisasi cerdas sampai pemrosesan data canggih, layanan backend yang ditenagai AI ini jadi makin penting banget buat aplikasi modern.</p>

                    <h2>Memahami AI dalam Konteks Backend</h2>
                    
                    <p>Integrasi AI di layanan backend itu melibatkan beberapa komponen penting:</p>

                    <ul>
                        <li><strong>Model Machine Learning:</strong> Model yang sudah dilatih buat bikin prediksi dan klasifikasi</li>
                        <li><strong>Natural Language Processing (NLP):</strong> Analisis dan pemahaman teks</li>
                        <li><strong>Computer Vision:</strong> Pemrosesan gambar dan video</li>
                        <li><strong>Sistem Rekomendasi:</strong> Ngasih konten yang dipersonalisasi ke pengguna</li>
                        <li><strong>Deteksi Anomali:</strong> Pemantauan keamanan dan performa</li>
                    </ul>

                    <h2>Implementasi RAG (Retrieval-Augmented Generation)</h2>
                    
                    <p>RAG itu teknik canggih yang gabungin pengambilan informasi relevan dengan pembuatan respons. Nah, ini dia cara implementasinya di backend kamu:</p>

                    <h3>1. Penyiapan Vector Database</h3>
                    <p>Gunakan database vektor kayak Pinecone, Weaviate, atau Chroma buat nyimpen embeddings:</p>

                    <pre><code>// Contoh dengan Pinecone
import { Pinecone } from '@pinecone-database/pinecone'

const pinecone = new Pinecone({
  apiKey: process.env.PINECONE_API_KEY
})

const index = pinecone.Index('knowledge-base')

// Simpan document embeddings
async function storeDocument(document) {
  const embedding = await generateEmbedding(document.text)
  
  await index.upsert([{
    id: document.id,
    values: embedding,
    metadata: {
      text: document.text,
      source: document.source
    }
  }])
}</code></pre>

                    <h3>2. Pembuatan Embedding</h3>
                    <p>Bikin embeddings buat dokumen kamu pake model kayak OpenAI's text-embedding-ada-002:</p>

                    <pre><code>// Bikin embeddings
async function generateEmbedding(text) {
  const response = await openai.embeddings.create({
    model: "text-embedding-ada-002",
    input: text
  })
  
  return response.data[0].embedding
}</code></pre>

                    <h3>3. Implementasi RAG Query</h3>
                    <p>Implementasi alur query RAG:</p>

                    <pre><code>async function ragQuery(question) {
  // 1. Bikin embedding buat pertanyaan
  const questionEmbedding = await generateEmbedding(question)
  
  // 2. Ambil dokumen yang relevan
  const searchResults = await index.query({
    vector: questionEmbedding,
    topK: 5,
    includeMetadata: true
  })
  
  // 3. Siapin context
  const context = searchResults.matches
    .map(match => match.metadata.text)
    .join('\n\n')
  
  // 4. Bikin respons pake LLM
  const response = await openai.chat.completions.create({
    model: "gpt-3.5-turbo",
    messages: [
      {
        role: "system",
        content: "You are a helpful assistant. Use the provided context to answer questions accurately."
      },
      {
        role: "user",
        content: \`Context: \${context}\n\nQuestion: \${question}\`
      }
    ]
  })
  
  return response.choices[0].message.content
}</code></pre>

                    <h2>Implementasi AI Agent</h2>
                    
                    <p>AI agents bisa ngerjain tugas kompleks secara mandiri. Ini dia cara bikinnya:</p>

                    <h3>1. Arsitektur Agent</h3>
                    <pre><code>class AIAgent {
  constructor(tools, llm) {
    this.tools = tools
    this.llm = llm
    this.memory = []
  }
  
  async execute(task) {
    const plan = await this.createPlan(task)
    
    for (const step of plan) {
      const result = await this.executeStep(step)
      this.memory.push({ step, result })
    }
    
    return this.memory
  }
  
  async createPlan(task) {
    const prompt = \`Buat rencana step-by-step untuk: \${task}\`
    const response = await this.llm.generate(prompt)
    return this.parsePlan(response)
  }
  
  async executeStep(step) {
    if (step.type === 'tool_use') {
      return await this.tools[step.tool].execute(step.parameters)
    } else if (step.type === 'llm_call') {
      return await this.llm.generate(step.prompt)
    }
  }
}</code></pre>

                    <h3>2. Integrasi Tools</h3>
                    <p>Definisikan tools yang bisa dipake agent:</p>

                    <pre><code>const tools = {
  searchDatabase: {
    execute: async (query) => {
      // Implementasi pencarian database
      return await database.search(query)
    }
  },
  
  sendEmail: {
    execute: async (params) => {
      // Implementasi kirim email
      return await emailService.send(params)
    }
  },
  
  callAPI: {
    execute: async (params) => {
      // Implementasi panggil API eksternal
      return await fetch(params.url, params.options)
    }
  }
}</code></pre>

                    <h2>Optimasi Performa</h2>
                    
                    <h3>1. Strategi Caching</h3>
                    <p>Implementasi caching buat respons model AI:</p>

                    <pre><code>// Redis caching buat embeddings
const redis = new Redis(process.env.REDIS_URL)

async function getCachedEmbedding(text) {
  const key = \`embedding:\${hash(text)}\`
  const cached = await redis.get(key)
  
  if (cached) {
    return JSON.parse(cached)
  }
  
  const embedding = await generateEmbedding(text)
  await redis.setex(key, 3600, JSON.stringify(embedding))
  
  return embedding
}</code></pre>

                    <h3>2. Batch Processing</h3>
                    <p>Proses multiple request dalam batch buat nambah efisiensi:</p>

                    <pre><code>async function batchProcessEmbeddings(texts) {
  const batchSize = 100
  const results = []
  
  for (let i = 0; i < texts.length; i += batchSize) {
    const batch = texts.slice(i, i + batchSize)
    const embeddings = await generateBatchEmbeddings(batch)
    results.push(...embeddings)
  }
  
  return results
}</code></pre>

                    <h2>Error Handling dan Monitoring</h2>
                    
                    <h3>1. Error Handling yang Robust</h3>
                    <pre><code>async function safeAICall(operation) {
  try {
    return await operation()
  } catch (error) {
    if (error.code === 'RATE_LIMIT') {
      await delay(1000) // Tunggu dan coba lagi
      return await operation()
    } else if (error.code === 'INVALID_INPUT') {
      throw new ValidationError('Input yang diberikan tidak valid')
    } else {
      logger.error('Operasi AI gagal', { error })
      throw new AIServiceError('Layanan AI sementara tidak tersedia')
    }
  }
}</code></pre>

                    <h3>2. Monitoring dan Metrics</h3>
                    <pre><code>// Track metrics layanan AI
const metrics = {
  requests: 0,
  errors: 0,
  avgResponseTime: 0,
  cacheHitRate: 0
}

function trackAIMetrics(operation, startTime, success) {
  metrics.requests++
  if (!success) metrics.errors++
  
  const responseTime = Date.now() - startTime
  metrics.avgResponseTime = 
    (metrics.avgResponseTime * (metrics.requests - 1) + responseTime) / metrics.requests
}</code></pre>

                    <h2>Pertimbangan Keamanan</h2>
                    
                    <h3>1. Validasi Input</h3>
                    <p>Selalu validasi dan sanitasi input ke layanan AI:</p>

                    <pre><code>function validateAIInput(input) {
  if (typeof input !== 'string') {
    throw new Error('Input harus berupa string')
  }
  
  if (input.length > 10000) {
    throw new Error('Input terlalu panjang')
  }
  
  // Cek konten yang berbahaya
  if (containsMaliciousContent(input)) {
    throw new Error('Input mengandung konten yang dilarang')
  }
  
  return sanitizeInput(input)
}</code></pre>

                    <h3>2. Manajemen API Key</h3>
                    <p>Kelola API key dan kredensial dengan aman:</p>

                    <pre><code>// Pake environment variables dan secret management
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
})

// Rotasi key secara berkala
async function rotateAPIKeys() {
  const newKey = await generateNewAPIKey()
  await updateSecret('OPENAI_API_KEY', newKey)
  await restartServices()
}</code></pre>

                    <h2>Strategi Deployment</h2>
                    
                    <h3>1. Container Deployment</h3>
                    <pre><code># Dockerfile buat layanan AI
FROM python:3.9-slim

WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .
EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]</code></pre>

                    <h3>2. Konfigurasi Kubernetes</h3>
                    <pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: ai-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: ai-service
  template:
    metadata:
      labels:
        app: ai-service
    spec:
      containers:
      - name: ai-service
        image: ai-service:latest
        ports:
        - containerPort: 8000
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"</code></pre>

                    <h2>Kesimpulan</h2>
                    
                    <p>Integrasi AI ke layanan backend buka peluang baru buat aplikasi yang lebih pintar. Dengan ngikutin pola dan best practices yang udah dijelasin di artikel ini, kamu bisa bikin layanan backend yang ditenagai AI yang robust, scalable, dan aman.</p>

                    <p>Ingat buat mulai dari implementasi yang sederhana dulu, terus tambah kompleksitas secara bertahap seiring pengalaman kamu. Selalu prioritaskan keamanan, performa, dan maintainability dalam integrasi AI kamu.</p>
                `
            },
            'kafka-simulator': {
                title: 'Kafka Simulator',
                date: 'December 20, 2024',
                readTime: 'Interactive Demo',
                icon: 'fas fa-chart-line',
                gradient: 'from-purple-500 to-pink-600',
                tags: ['JavaScript', 'HTML5', 'Kafka', 'Interactive'],
                cover: 'https://images.unsplash.com/photo-1551288049-bebda4e38f71?auto=format&fit=crop&w=1200&q=80',
                content: `
                    <h1>Kafka Simulator - Interactive Learning Tool</h1>
                    
                    <p>The Kafka Simulator is an interactive web-based tool designed to help developers understand Apache Kafka concepts through hands-on experimentation. This tool provides a visual representation of how Kafka works, making it easier to grasp complex concepts like partitions, consumers, and message flow.</p>

                    <h2>Why Build a Kafka Simulator?</h2>
                    
                    <p>Learning Kafka can be challenging due to its distributed nature and complex concepts. A simulator helps by:</p>

                    <ul>
                        <li><strong>Visual Learning:</strong> Seeing concepts in action makes them easier to understand</li>
                        <li><strong>Safe Experimentation:</strong> Try different configurations without affecting production systems</li>
                        <li><strong>Immediate Feedback:</strong> See results instantly as you change parameters</li>
                        <li><strong>Cost-Effective:</strong> No need to set up complex Kafka clusters for learning</li>
                    </ul>

                    <h2>Key Features</h2>
                    
                    <h3>1. Interactive Configuration</h3>
                    <p>Users can configure various Kafka parameters:</p>

                    <ul>
                        <li><strong>Partitions:</strong> Number of partitions (1-12)</li>
                        <li><strong>Brokers:</strong> Number of broker nodes (1-9)</li>
                        <li><strong>Replication Factor:</strong> Data replication level (1-3)</li>
                        <li><strong>Producer Settings:</strong> Message production rate and partitioning strategy</li>
                        <li><strong>Consumer Settings:</strong> Consumption rate and commit policies</li>
                    </ul>

                    <h3>2. Real-time Visualization</h3>
                    <p>The simulator provides real-time visualization of:</p>

                    <ul>
                        <li>Message flow between producers and consumers</li>
                        <li>Partition assignment and rebalancing</li>
                        <li>Broker status and failover scenarios</li>
                        <li>Offset tracking and commit operations</li>
                        <li>ISR (In-Sync Replicas) status</li>
                    </ul>

                    <h3>3. Learning Scenarios</h3>
                    <p>Predefined scenarios help users understand different concepts:</p>

                    <ul>
                        <li><strong>Basic Produce-Consume:</strong> Simple message flow</li>
                        <li><strong>Partitioning Strategies:</strong> Round-robin vs key-based partitioning</li>
                        <li><strong>Consumer Groups:</strong> Load balancing and rebalancing</li>
                        <li><strong>Fault Tolerance:</strong> Broker failures and recovery</li>
                        <li><strong>Performance Tuning:</strong> Optimizing throughput and latency</li>
                    </ul>

                    <h2>Technical Implementation</h2>
                    
                    <h3>1. Frontend Architecture</h3>
                    <p>Built using vanilla JavaScript with modern web technologies:</p>

                    <pre><code>// Core simulation engine
class KafkaSimulator {
  constructor() {
    this.state = {
      partitions: 3,
      brokers: 3,
      replicationFactor: 1,
      producers: [],
      consumers: [],
      messages: [],
      isRunning: false
    }
  }
  
  start() {
    this.isRunning = true
    this.startProducer()
    this.startConsumers()
    this.render()
  }
  
  stop() {
    this.isRunning = false
    this.clearTimers()
  }
}</code></pre>

                    <h3>2. Message Flow Simulation</h3>
                    <p>Simulates realistic message production and consumption:</p>

                    <pre><code>// Producer simulation
startProducer() {
  const interval = this.state.produceInterval / this.state.speed
  this.producerTimer = setInterval(() => {
    const partition = this.choosePartition()
    const message = this.createMessage()
    
    this.state.messages.push({
      id: message.id,
      partition: partition,
      offset: this.getNextOffset(partition),
      timestamp: Date.now(),
      content: message.content
    })
    
    this.render()
  }, interval)
}</code></pre>

                    <h3>3. Consumer Group Management</h3>
                    <p>Implements consumer group rebalancing logic:</p>

                    <pre><code>// Consumer group rebalancing
rebalanceConsumers() {
  const consumers = this.state.consumers
  const partitions = this.state.partitions
  
  // Clear current assignments
  consumers.forEach(consumer => {
    consumer.assignedPartitions = []
  })
  
  // Assign partitions using round-robin
  for (let i = 0; i < partitions; i++) {
    const consumerIndex = i % consumers.length
    consumers[consumerIndex].assignedPartitions.push(i)
  }
  
  this.renderConsumers()
}</code></pre>

                    <h2>Educational Value</h2>
                    
                    <h3>1. Concept Visualization</h3>
                    <p>The simulator makes abstract concepts concrete:</p>

                    <ul>
                        <li><strong>Partitions:</strong> Visual representation of data distribution</li>
                        <li><strong>Offsets:</strong> Clear tracking of message positions</li>
                        <li><strong>Consumer Groups:</strong> Visual assignment and rebalancing</li>
                        <li><strong>Replication:</strong> Leader-follower relationships</li>
                    </ul>

                    <h3>2. Interactive Learning</h3>
                    <p>Users can experiment with different scenarios:</p>

                    <ul>
                        <li>Add/remove consumers and observe rebalancing</li>
                        <li>Change partitioning strategies and see the impact</li>
                        <li>Simulate broker failures and recovery</li>
                        <li>Adjust performance parameters and measure results</li>
                    </ul>

                    <h2>Performance Considerations</h2>
                    
                    <h3>1. Efficient Rendering</h3>
                    <p>Optimized rendering for smooth performance:</p>

                    <pre><code>// Efficient DOM updates
render() {
  requestAnimationFrame(() => {
    this.updateMessageDisplay()
    this.updateConsumerStatus()
    this.updateBrokerStatus()
  })
}

updateMessageDisplay() {
  const container = document.getElementById('messages')
  const messages = this.state.messages.slice(-50) // Show last 50 messages
  
  container.innerHTML = messages.map(msg => 
    \`<div class="message" data-partition="\${msg.partition}">
      \${msg.content} (P\${msg.partition}:\${msg.offset})
    </div>\`
  ).join('')
}</code></pre>

                    <h3>2. Memory Management</h3>
                    <p>Prevents memory leaks in long-running simulations:</p>

                    <pre><code>// Cleanup old messages
cleanupMessages() {
  const maxMessages = 1000
  if (this.state.messages.length > maxMessages) {
    this.state.messages = this.state.messages.slice(-maxMessages)
  }
}</code></pre>

                    <h2>Future Enhancements</h2>
                    
                    <h3>1. Advanced Scenarios</h3>
                    <ul>
                        <li>Schema registry integration</li>
                        <li>Stream processing with Kafka Streams</li>
                        <li>Connect framework simulation</li>
                        <li>Security and authentication scenarios</li>
                    </ul>

                    <h3>2. Performance Metrics</h3>
                    <ul>
                        <li>Throughput measurement</li>
                        <li>Latency tracking</li>
                        <li>Resource utilization monitoring</li>
                        <li>Comparative analysis tools</li>
                    </ul>

                    <h2>Conclusion</h2>
                    
                    <p>The Kafka Simulator demonstrates how interactive tools can make complex technologies more accessible. By providing a visual, hands-on learning experience, it helps developers understand Kafka concepts more effectively than traditional documentation alone.</p>

                    <p>This project showcases the power of combining educational content with interactive technology to create engaging learning experiences that benefit the entire developer community.</p>

                    <div class="mt-8 p-6 bg-blue-50 rounded-lg">
                        <h3 class="text-lg font-semibold text-blue-900 mb-2">Try the Simulator</h3>
                        <p class="text-blue-800 mb-4">Experience the Kafka Simulator yourself and explore different scenarios to deepen your understanding of Apache Kafka.</p>
                        <a href="kafka-simulator.html" class="inline-block bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 transition-colors">
                            Launch Simulator →
                        </a>
                    </div>
                `
            }
        };

        // Get blog post from URL parameter
        function getBlogPostFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('post') || 'golang-microservices';
        }

        // Populate blog details
        function populateBlogDetails() {
            const postId = getBlogPostFromURL();
            const post = blogPosts[postId];

            if (!post) {
                console.error('Blog post not found:', postId);
                return;
            }

            // Update page title
            document.title = `${post.title} - Blog - Rahadi Sampurna`;

            // Populate blog header
            const header = document.getElementById('blog-header');
            header.innerHTML = `
                <div class="bg-white rounded-xl shadow-lg overflow-hidden">
                    <div class="h-64 bg-cover bg-center" style="background-image:url('${post.cover || 'https://images.unsplash.com/photo-1519389950473-47ba0277781c?auto=format&fit=crop&w=1200&q=80'}');">
                        <div class="h-full bg-gradient-to-br ${post.gradient} flex items-center justify-center">
                        <i class="${post.icon} text-8xl text-white"></i>
                        </div>
                    </div>
                    <div class="p-8">
                        <div class="flex items-center justify-between mb-4">
                            <h1 class="text-4xl font-bold text-gray-900">${post.title}</h1>
                            <div class="text-right">
                                <div class="text-lg text-gray-500">${post.date}</div>
                                <div class="text-sm text-gray-400">${post.readTime}</div>
                            </div>
                        </div>
                        <div class="flex flex-wrap gap-2">
                            ${post.tags.map(tag => 
                                `<span class="bg-gray-100 text-gray-800 px-3 py-1 rounded-full text-sm">${tag}</span>`
                            ).join('')}
                        </div>
                    </div>
                </div>
            `;

            // Populate blog content
            document.getElementById('blog-content').innerHTML = post.content;

            // Inject JSON-LD for BlogPosting
            const ld = {
              "@context": "https://schema.org",
              "@type": "BlogPosting",
              "headline": post.title,
              "image": post.cover,
              "author": { "@type": "Person", "name": "Rahadi Sampurna" },
              "publisher": { "@type": "Person", "name": "Rahadi Sampurna" },
              "datePublished": post.date,
              "url": window.location.href
            };
            document.getElementById('ld-json').textContent = JSON.stringify(ld);

            // Populate tags
            document.getElementById('blog-tags').innerHTML = post.tags.map(tag => 
                `<span class="bg-blue-100 text-blue-800 px-3 py-1 rounded-full text-sm">${tag}</span>`
            ).join('');
        }

        // Initialize page
        document.addEventListener('DOMContentLoaded', populateBlogDetails);
    </script>
</body>
</html>
